[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "COMP/STAT212 Portfolio",
    "section": "",
    "text": "Welcome\nWelcome to my online portfolio for COMP/STAT112 course taken at Macalester College. Please, use the side bar on the left for navigation.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "src/pv/pv-01.html",
    "href": "src/pv/pv-01.html",
    "title": "Professional Viz Sample",
    "section": "",
    "text": "Codelibrary(readr)\nlibrary(tidyverse)\nlibrary(httr2)\nlibrary(xml2)\ntimes_key &lt;- read_lines(\"pv.txt\")\n\n\n\nCodecreate_nyt_url &lt;- function(section = \"viewed\", period = 1, key) {\n  request(\"https://api.nytimes.com\") |&gt;\n    req_url_path_append(\"svc\", \"mostpopular\", \"v2\", paste0(section, \"/\", period, \".json\")) |&gt;\n    req_url_query(`api-key` = key)\n}\n\n\n\nCodereq_most_viewed &lt;- create_nyt_url(\"viewed\", 1, times_key)\nresp &lt;- req_perform(req_most_viewed)\ndata &lt;- resp_body_json(resp)\n\ntitles &lt;- sapply(data$results, function(x) x$title)\n\nsection &lt;- sapply(data$results, function(x) x$section)\nsection &lt;- as.data.frame(section)\n\n\n\nCode# install.packages(c(\"tm\", \"SnowballC\", \"wordcloud\", \"RColorBrewer\"))\nlibrary(\"tm\")\nlibrary(\"SnowballC\")\nlibrary(\"wordcloud\")\nlibrary(\"RColorBrewer\")\n\n\n\nCodetitles &lt;- str_replace_all(titles, \"[[:punct:]]\", \"\")\ntitles &lt;- as.data.frame(titles)\n\n\ndocs &lt;- Corpus(VectorSource(titles))\n\ndocs &lt;- tm_map(docs, content_transformer(tolower)) # Convert to lowercase\ndocs &lt;- tm_map(docs, removeNumbers) # Remove numbers\ndocs &lt;- tm_map(docs, removeWords, stopwords(\"english\")) # Remove common English stop words\ndocs &lt;- tm_map(docs, removePunctuation) # Remove punctuation\ndocs &lt;- tm_map(docs, stripWhitespace) # Remove extra whitespace\n\n\n\nCodedtm &lt;- TermDocumentMatrix(docs)\nm &lt;- as.matrix(dtm)\nv &lt;- sort(rowSums(m), decreasing = TRUE)\nd &lt;- data.frame(word = names(v), freq = v)\n\n\n\nCodeif(require(RColorBrewer)){\n\n        pal &lt;- brewer.pal(9,\"BuGn\")\n        pal &lt;- pal[-(1:4)]\n        wordcloud(d$word,d$freq,c(8,.3),2,,FALSE,,.15,pal)\n\n\n        pal &lt;- brewer.pal(6,\"Dark2\")\n        pal &lt;- pal[-(1)]\n        wordcloud(d$word,d$freq,c(8,.3),2,,TRUE,,.15,pal)\n        \n        #random colors\n        wordcloud(d$word,d$freq,c(8,.3),2,,TRUE,TRUE,.15,pal)\n    }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCodewordcloud(d)",
    "crumbs": [
      "Prof Viz",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Professional Viz Sample</span>"
    ]
  },
  {
    "objectID": "src/tt/2025-07-08.html",
    "href": "src/tt/2025-07-08.html",
    "title": "Illegal Cheetah Trade",
    "section": "",
    "text": "Global dataset for seized and non-intercepted illegal cheetah trade (Acinonyx jubatus) 2010‚Äì2019",
    "crumbs": [
      "TidyTuesday",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Illegal Cheetah Trade</span>"
    ]
  },
  {
    "objectID": "src/tt/2025-07-08.html#global-dataset-for-seized-and-non-intercepted-illegal-cheetah-trade-acinonyx-jubatus-20102019",
    "href": "src/tt/2025-07-08.html#global-dataset-for-seized-and-non-intercepted-illegal-cheetah-trade-acinonyx-jubatus-20102019",
    "title": "Illegal Cheetah Trade",
    "section": "",
    "text": "Variables\nThe variables within this dataset include: - Incident No.; Assigned by researcher\n- Incident Type; Animal Injury / Mortality / Welfare Possession/trade Seizure\n- Incident Date; DD-MMM-YY, TOTALS\n- Discovery Date; DD-MMM-YY (date when incident was discovered by researcher)\n- Country Role; O = Origin T = Transit D = Destination\n- Region\n- Country\n- City/Region\n- Location Type; Unknown, Rural area, Border Crossing, Private Home, Airport, Farm, etc.\n- Origin if known\n- Transit if known\n- Destination if known\n- Report grading;\n- Verif means; Photo and/or video, official records, source reliability, known sellers, image search.\n- Ultimate Source Type; A = Official, B = Database, C = Primary, D = Secondary, E = Seller\n- Ult.Verif.Source; E.g., photo, video, official records, site visit\n- Ult.Source Reliability; A = always B = mostly C = fairly D = sometimes E = unreliable F = unknown\n- Orig.Source Type; A = Original research B = Official C = Open source D = Direct Report\n- Medium; e.g.¬†Email, phone, report, database\n- Original Source; Name or identifier\n- Day\n- Month\n- Year\n- Number of Cheetahs; If known and in full cheetah units.\n- Units; Bushmeat, Claws, Head, Live, Other, Skin, Skin pieces, Skull, Stuffed, Teeth, Trophy\n- Incident Description\n- Confiscated; number of units\n- Surrendered\n- Alive; number of live units at or post confiscation\n- Died; number of death units at or following confiscation if known\n- LTF / UNK Fate; number of units lost to follow up or unknown fate\n- Action Taken\n- Outcome\n- Detecting Agency\n- POI Assigned ID\n- Other info / URL\n\nCodestr(data)\n\ntibble [1,886 √ó 38] (S3: tbl_df/tbl/data.frame)\n $ Incident No.           : chr [1:1886] NA NA \"PT-2010-001\" \"PT-2010-002\" ...\n $ Incident Type          : chr [1:1886] \"Animal Injury / Mortality / Welfare\\r\\nPossession/trade\\r\\nSeizure\" NA \"Seizure\" \"Seizure\" ...\n $ Incident Date          : chr [1:1886] NA \"TOTALS\" \"40191\" \"40192\" ...\n $ Discovery Date         : num [1:1886] NA NA 44070 42300 41149 ...\n $ Country Role           : chr [1:1886] \"O = Origin\\r\\nT = Transit\\r\\nD = Destination\" NA \"D\" \"O\" ...\n $ Region                 : chr [1:1886] NA NA \"Europe\" \"East Africa\" ...\n $ Country                : chr [1:1886] NA NA \"Spain\" \"Kenya\" ...\n $ City/Region            : chr [1:1886] NA NA NA \"Mombasa\" ...\n $ Location Type          : chr [1:1886] NA NA \"Unknown\" \"Rural area\" ...\n $ Origin if known        : chr [1:1886] NA NA NA NA ...\n $ Transit if known       : chr [1:1886] NA NA \"E Europe\" NA ...\n $ Destination if known   : chr [1:1886] NA NA NA NA ...\n $ Report grading         : chr [1:1886] \"A = True\\r\\nB = Second hand but source known\\r\\nC = Unknown but corroborated\\r\\nD = Unable to Judge\\r\\nE = Suspected false\" NA \"D\" \"A\" ...\n $ Verif means            : chr [1:1886] NA NA \"Invest. report\" \"Seizure\" ...\n $ Ultimate source type   : chr [1:1886] \"A = Primary\\r\\nB = Secondary\" NA \"C\" \"A\" ...\n $ Ult. Verif. Source     : chr [1:1886] \"Description\" NA \"El Mundo (ES)\" \"Original source\" ...\n $ Ult. Source Reliability: chr [1:1886] \"A = always\\r\\nB = mostly\\r\\nC = fairly\\r\\nD = sometimes\\r\\nE = unreliable\\r\\nF = unknown\" NA \"C\" \"A\" ...\n $ Orig. Source Type      : chr [1:1886] \"A = Original research\\r\\nB = Official\\r\\nC = Open source\\r\\nD = Direct Report\" NA \"C\" \"B\" ...\n $ Medium                 : chr [1:1886] NA NA \"Media\" \"Web site/Direct\" ...\n $ Original Source        : chr [1:1886] NA NA \"24minutes.es\" \"CITES MA\" ...\n $ Day                    : chr [1:1886] NA NA \"13\" \"14\" ...\n $ Month                  : chr [1:1886] NA NA \"1\" \"1\" ...\n $ Year                   : chr [1:1886] NA NA \"2010\" \"2010\" ...\n $ Day (+/-)              : chr [1:1886] \"When exact date not known\" NA NA NA ...\n $ Month (+/-)            : chr [1:1886] \"When exact date not known\" NA \"-1\" NA ...\n $ # Cheetahs             : chr [1:1886] NA \"4184\" \"1\" \"1\" ...\n $ Units                  : chr [1:1886] \"Bushmeat\\r\\nClaws\\r\\nHead\\r\\nLive\\r\\nOther\\r\\nSkin\\r\\nSkin pieces\\r\\nSkull\\r\\nStuffed\\r\\nTeeth\\r\\nTrophy\" NA \"Live\" \"Skin\" ...\n $ Incident Description   : chr [1:1886] NA NA \"cheetah, lions,  tiger, Iberian wolf, European Lynx, 3 pumas, eagle and falcons seized. Animals were transporte\"| __truncated__ \"Transported on land as luggage, confiscated by KWS\" ...\n $ Confiscated            : chr [1:1886] \"# of units if known\" \"736\" \"1\" \"1\" ...\n $ Surrendered            : num [1:1886] NA 20 0 0 0 0 0 0 0 0 ...\n $ Alive                  : chr [1:1886] \"# live units at or post confiscation\" \"342\" \"1\" \"0\" ...\n $ Died                   : chr [1:1886] \"# death units at or post confiscation\" \"759\" \"0\" \"1\" ...\n $ LTF/ UNK Fate          : chr [1:1886] \"# units lost to follow up\" \"3083\" \"0\" \"0\" ...\n $ Action Taken           : chr [1:1886] NA NA \"Confiscated by SEPRONA as part of Operation \\\"Lobezno\\\"\" NA ...\n $ Outcome                : chr [1:1886] NA NA \"Eight people who sold wildlife products on the internet were arrested. Article provides data on detainees.\" \"1 arrested, 1  prosecuted for Illegal  possession and dealing.  1 given 18 months imprisonment or Kshs 63,000 in default\" ...\n $ Detecting agency       : chr [1:1886] NA NA \"SEPRONA (Nature Protection Service)\" \"Kenya Wildlife Service (KWS)\" ...\n $ POI Assigned ID        : chr [1:1886] \"Suspects, person of interest\" NA \"Unknown x 8\" \"Unknown\" ...\n $ Other info / URL       : chr [1:1886] \"URLs\" NA \"https://www.laregion.es/articulo/galicia/desarticulada-red-traficaba-especies-protegidas-comunidades-ellas-gali\"| __truncated__ \"https://cites.org/sites/default/files/eng/com/sc/66/E-SC66-32-05_Annex.pdf\" ...\n\n\nResearch Questions Development\nWhere were all live cheetahs found?\n\n\n\n\n\n\n\nI would like to use location to better understand how and what happened in these recorded illegal cheetah trade incidents. For example, I could bind this location data to different variables in the dataset to show spatially how many cheetahs were found in these countries.\nHow many cheetahs were found throughout the years?\n\n\n\n\n\n\n\n\n\nThis plot helped me see how many cheetahs were counted in all of the incidents recorded. I believe this can help me delve into questions such as:\n¬†\n\nHow are illegal cheetah trade incidents changing in their locations, units, and incident types throughout the years?\nWhat are the most common incidents seen in the illegal cheetah trade?",
    "crumbs": [
      "TidyTuesday",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Illegal Cheetah Trade</span>"
    ]
  },
  {
    "objectID": "src/tt/2025-07-15.html",
    "href": "src/tt/2025-07-15.html",
    "title": "Cranes Sightings in Sweden",
    "section": "",
    "text": "Codelibrary(dplyr)\nlibrary(lubridate)\n\ncranes$date &lt;- ymd(cranes$date)\ncranes$month &lt;- month(cranes$date, label = TRUE)\ncranes$day &lt;- day(cranes$date)\ncranes$year &lt;- year(cranes$date)\ncranes$day_of_year &lt;- yday(cranes$date)\n\n\n\nCodelibrary(ggplot2)\nline &lt;- cranes |&gt; \n  filter(!is.na(observations)) |&gt; \n  group_by(month) |&gt; \n  summarize(observations = mean(observations)) |&gt; \n  mutate(month = factor(month, level = month.abb))\n\nggplot(line, aes(x = month, y = observations)) +\n  geom_col() +\n  labs(title = \"Total Mean Observations by Month\")\n\n\n\n\n\n\n\n\nCodeggplot(cranes, aes(x = date)) +\n  geom_point(aes(y = observations, color = weather_disruption), size = 3, na.rm = TRUE) +\n  labs(title = \"Observations and Weather Disruptions\",\n       y = \"Observations\", color = \"Weather Disruption\")\n\n\n\n\n\n\nCodecranes |&gt; \n  filter(weather_disruption == TRUE) |&gt; \n  count()\n\n# A tibble: 1 √ó 1\n      n\n  &lt;int&gt;\n1    41",
    "crumbs": [
      "TidyTuesday",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Cranes Sightings in Sweden</span>"
    ]
  },
  {
    "objectID": "src/ica/ica-sample1.html",
    "href": "src/ica/ica-sample1.html",
    "title": "02 Review",
    "section": "",
    "text": "Codelibrary(tidyverse)\nweather &lt;- read_csv(\"https://mac-stat.github.io/data/sfo_weather.csv\")\n\n\n\nCodelibrary(dplyr)\nlibrary(tidyverse)\nlibrary(lubridate)\nlibrary(readr)\n\nweather &lt;- read_csv(\"../../../portfolio-cluno113/data/raw/weather.csv\")\n\nweather &lt;- weather %&gt;% \n  mutate(PrecipYr = na_if(PrecipYr, 99999)) \n  \nweather &lt;- weather %&gt;% \n  mutate(date = as.Date(date, format = \"%m/%d/%y\")) %&gt;% \n  mutate(day_of_year = yday(date))\n\nweather_clean &lt;- weather %&gt;% \n  mutate(month_name = format(date, \"%b\"))\n\nwrite_csv(weather_clean, \"../../../portfolio-cluno113/data/raw/weather_clean.csv\")\n\nweather_clean &lt;- weather_clean |&gt; \n  janitor::clean_names()\n\nweather_clean$date &lt;- as.Date(weather_clean$date - 1, origin = \"2021-01-01\")\n\ntemp &lt;- ggplot(weather_clean, aes(x = date)) +\n  geom_linerange(aes(\n    ymin = record_low,\n    ymax = record_high),\n    color = \"#ECEBE3\") +\n  geom_linerange(aes(\n    ymin = normal_low,\n    ymax = normal_high),\n    color = \"#C8B8BA\") +\n  geom_linerange(aes(\n    ymin = low,\n    ymax = high),\n    color = \"#A90248\") +\n  scale_x_date(\n    date_labels = \"%b\",        # Short month names (Jan, Feb, ...)\n    date_breaks = \"1 month\"    # Tick every month\n  ) +\n  theme_classic() +\n  theme(axis.title = element_blank(),\n    axis.text.y = element_text(size = 8),\n    axis.text.x = element_text(size = 9),\n    panel.grid = element_blank())\n\n\n\nCodeprec &lt;- ggplot(weather_clean) +\n  geom_area(aes(x = date, y = culm_prec), fill = \"#ebeae2\", color = \"#32a3d8\") +\n  geom_point(\n    data = subset(weather_clean, record_precip == TRUE),\n    aes(y = culm_prec),\n    shape = 17,\n    size = 2,\n    color = \"#32a3d8\"\n  ) +\n  scale_x_date(date_labels = \"%b\", date_breaks = \"1 month\") +\n  theme_classic()\n\n\n\nCodelibrary(patchwork)\ntemp / prec + plot_layout(widths = c(2, 1), heights = c(3, 1))",
    "crumbs": [
      "In-Class Activities",
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>02 Review</span>"
    ]
  },
  {
    "objectID": "src/ica/06_adv_data_wrangling_p1/06-wrangling-1-notes.html",
    "href": "src/ica/06_adv_data_wrangling_p1/06-wrangling-1-notes.html",
    "title": "6 Adv Data wrangling P1",
    "section": "",
    "text": "üß© Learning Goals\nBy the end of this lesson, you should be able to:",
    "crumbs": [
      "In-Class Activities",
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>6 Adv Data wrangling P1</span>"
    ]
  },
  {
    "objectID": "src/ica/06_adv_data_wrangling_p1/06-wrangling-1-notes.html#learning-goals",
    "href": "src/ica/06_adv_data_wrangling_p1/06-wrangling-1-notes.html#learning-goals",
    "title": "6 Adv Data wrangling P1",
    "section": "",
    "text": "Determine the class of a given object and identify concerns to be wary of when manipulating an object of that class (numerics, logicals, factors, dates, strings, data.frames)\nExplain what vector recycling is, when it can be a problem, and how to avoid those problems\nUse a variety of functions to wrangle numerical and logical data\nExtract date-time information using the lubridate package\nUse the forcats package to wrangle factor data",
    "crumbs": [
      "In-Class Activities",
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>6 Adv Data wrangling P1</span>"
    ]
  },
  {
    "objectID": "src/ica/06_adv_data_wrangling_p1/06-wrangling-1-notes.html#helpful-cheatsheets",
    "href": "src/ica/06_adv_data_wrangling_p1/06-wrangling-1-notes.html#helpful-cheatsheets",
    "title": "6 Adv Data wrangling P1",
    "section": "Helpful Cheatsheets",
    "text": "Helpful Cheatsheets\nRStudio (Posit) maintains a collection of wonderful cheatsheets. The following will be helpful:\n\nData transformation with dplyr\nDates and times with lubridate\nFactors with forcats\n\nData Wrangling Verbs (from Stat/Comp 112)\n\n\nmutate(): creates/changes columns/elements in a data frame/tibble\n\nselect(): keeps subset of columns/elements in a data frame/tibble\n\nfilter(): keeps subsets of rows in a data frame/tibble\n\narrange(): sorts rows in a data frame/tibble\n\ngroup_by(): internally groups rows in data frame/tibble by values in 1 or more columsn/elements\n\nsummarize(): collapses/combines information across rows using functions such as n(), sum(), mean(), min(), max(), median(), sd()\n\n\ncount(): shortcut for group_by() |&gt; summarize(n = n())\n\n\nleft_join(): mutating join of two data frames/tibbles keeping all rows in left data frame\n\nfull_join(): mutating join of two data frames/tibbles keeping all rows in both data frames\n\ninner_join(): mutating join of two data frames/tibbles keeping rows in left data frame that find match in right\n\nsemi_join(): filtering join of two data frames/tibbles keeping rows in left data frame that find match in right\n\nanti_join(): filtering join of two data frames/tibbles keeping rows in left data frame that do not find match in right\n\npivot_wider(): rearrange values from two columns to many(one column becomes the names of new variables, one column becomes the values of the new variables)\n\npivot_longer(): rearrange values from many columns to two (the names of the columns go to one new variable, the values of the columns go to a second new variable)",
    "crumbs": [
      "In-Class Activities",
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>6 Adv Data wrangling P1</span>"
    ]
  },
  {
    "objectID": "src/ica/06_adv_data_wrangling_p1/06-wrangling-1-notes.html#vectors",
    "href": "src/ica/06_adv_data_wrangling_p1/06-wrangling-1-notes.html#vectors",
    "title": "6 Adv Data wrangling P1",
    "section": "Vectors",
    "text": "Vectors\nAn atomic vector is a storage container in R where all elements in the container are of the same type. The types that are relevant to data science are:\n\n\nlogical (also known as boolean)\nnumbers\n\ninteger\n\nnumeric floating point (also known as double)\n\n\n\ncharacter string\n\nDate and date-time (saved as POSIXct)\nfactor\n\nFunction documentation will refer to vectors frequently.\nSee examples below:\n\n\nggplot2::scale_x_continuous()\n\n\nbreaks: A numeric vector of positions\n\nlabels: A character vector giving labels (must be same length as breaks)\n\n\n\nshiny::sliderInput()\n\n\nvalue: The initial value of the slider [‚Ä¶] A length one vector will create a regular slider; a length two vector will create a double-ended range slider.\n\n\n\nWhen you need a vector, you can create one manually using\n\n\nc(): the combine function\n\nOr you can create one based on available data using\n\n\ndataset |&gt; mutate(newvar = variable &gt; 5) |&gt; pull(newvar): taking one column out of a dataset\n\ndataset |&gt; pull(variable) |&gt; unique(): taking one column out of a dataset and finding unique values\n\n\nCodec(\"Fair\", \"Good\", \"Very Good\", \"Premium\", \"Ideal\")\n\n[1] \"Fair\"      \"Good\"      \"Very Good\" \"Premium\"   \"Ideal\"    \n\nCodediamonds |&gt; pull(cut) |&gt; unique()\n\n[1] Ideal     Premium   Good      Very Good Fair     \nLevels: Fair &lt; Good &lt; Very Good &lt; Premium &lt; Ideal",
    "crumbs": [
      "In-Class Activities",
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>6 Adv Data wrangling P1</span>"
    ]
  },
  {
    "objectID": "src/ica/06_adv_data_wrangling_p1/06-wrangling-1-notes.html#logicals",
    "href": "src/ica/06_adv_data_wrangling_p1/06-wrangling-1-notes.html#logicals",
    "title": "6 Adv Data wrangling P1",
    "section": "Logicals",
    "text": "Logicals\nNotes\nWhat does a logical vector look like?\n\nCodex &lt;- c(TRUE, FALSE, NA)\nx\n\n[1]  TRUE FALSE    NA\n\nCodeclass(x)\n\n[1] \"logical\"\n\n\nYou will often create logical vectors with comparison operators: &gt;, &lt;, &lt;=, &gt;=, ==, !=.\n\nCodex &lt;- c(1, 2, 9, 12)\nx &lt; 2\n\n[1]  TRUE FALSE FALSE FALSE\n\nCodex &lt;= 2\n\n[1]  TRUE  TRUE FALSE FALSE\n\nCodex &gt; 9\n\n[1] FALSE FALSE FALSE  TRUE\n\nCodex &gt;= 9\n\n[1] FALSE FALSE  TRUE  TRUE\n\nCodex == 12\n\n[1] FALSE FALSE FALSE  TRUE\n\nCodex != 12\n\n[1]  TRUE  TRUE  TRUE FALSE\n\n\nWhen you want to check for set containment, the %in% operator is the correct way to do this (as opposed to ==).\n\nCodex &lt;- c(1, 2, 9, 4)\nx == c(1, 2, 4)\n\nWarning in x == c(1, 2, 4): longer object length is not a multiple of shorter\nobject length\n\n\n[1]  TRUE  TRUE FALSE FALSE\n\nCodex %in% c(1, 2, 4)\n\n[1]  TRUE  TRUE FALSE  TRUE\n\n\nThe Warning: longer object length is not a multiple of shorter object length is a manifestation of vector recycling.\nIn R, if two vectors are being combined or compared, the shorter one will be repeated to match the length of the longer one‚Äìeven if longer object length isn‚Äôt a multiple of the shorter object length. We can see the exact recycling that happens below:\n\nCodex &lt;- c(1, 2, 9, 4)\nx == c(1, 2, 4)\n\n[1]  TRUE  TRUE FALSE FALSE\n\nCodex == c(1, 2, 4, 1) # This line demonstrates the recycling that happens on the previous line\n\n[1]  TRUE  TRUE FALSE FALSE\n\n\nLogical vectors can also be created with functions. is.na() is one useful example:\n\nCodex &lt;- c(1, 4, 9, NA)\nx == NA\n\n[1] NA NA NA NA\n\nCodeis.na(x)\n\n[1] FALSE FALSE FALSE  TRUE\n\n\nWe can negate a logical object with !. We can combine logical objects with & (and) and | (or).\n\nCodex &lt;- c(1, 2, 4, 9)\nx &gt; 1 & x &lt; 5\n\n[1] FALSE  TRUE  TRUE FALSE\n\nCode!(x &gt; 1 & x &lt; 5)\n\n[1]  TRUE FALSE FALSE  TRUE\n\nCodex &lt; 2 | x &gt; 8\n\n[1]  TRUE FALSE FALSE  TRUE\n\n\nWe can summarize logical vectors with:\n\n\nany(): Are ANY of the values TRUE?\n\nall(): Are ALL of the values TRUE?\n\nsum(): How many of the values are TRUE?\n\nmean(): What fraction of the values are TRUE?\n\n\nCodex &lt;- c(1, 2, 4, 9)\nany(x == 1)\n\n[1] TRUE\n\nCodeall(x &lt; 10)\n\n[1] TRUE\n\nCodesum(x == 1)\n\n[1] 1\n\nCodemean(x == 1)\n\n[1] 0.25\n\n\nif_else() and case_when() are functions that allow you to return values depending on the value of a logical vector. You‚Äôll explore the documentation for these in the following exercises.\n\n\n\n\n\n\nNote: ifelse() (from base R) and if_else() (from tidyverse) are different functions. We prefer if_else() for many reasons (examples below).\n\nNoisy to make sure you catch issues/bugs\nCan explicitly handle missing values\nKeeps dates as dates\n\n\nExamples\n\nCodex &lt;- c(-1, -2, 4, 9, NA)\n\nifelse(x &gt; 0, 'positive', 'negative')\n\n[1] \"negative\" \"negative\" \"positive\" \"positive\" NA        \n\nCodeif_else(x &gt; 0, 'positive', 'negative')\n\n[1] \"negative\" \"negative\" \"positive\" \"positive\" NA        \n\nCodeifelse(x &gt; 0, 1, 'negative') # Bad: doesn't complain with combo of data types\n\n[1] \"negative\" \"negative\" \"1\"        \"1\"        NA        \n\nCodeif_else(x &gt; 0, 1, 'negative') # Good:noisy to make sure you catch issues\n\nError in `if_else()`:\n! Can't combine `true` &lt;double&gt; and `false` &lt;character&gt;.\n\nCodeif_else(x &gt; 0, 'positive', 'negative', missing = 'missing') # Good: can explicitly handle NA\n\n[1] \"negative\" \"negative\" \"positive\" \"positive\" \"missing\" \n\nCodefun_dates &lt;- mdy('1-1-2025') + 0:365\nifelse(fun_dates &lt; today(), fun_dates + years(), fun_dates) # Bad: converts dates to integers\n\n  [1] 20454 20455 20456 20457 20458 20459 20460 20461 20462 20463 20464 20465\n [13] 20466 20467 20468 20469 20470 20471 20472 20473 20474 20475 20476 20477\n [25] 20478 20479 20480 20481 20482 20483 20484 20485 20486 20487 20488 20489\n [37] 20490 20491 20492 20493 20494 20495 20496 20497 20498 20499 20500 20501\n [49] 20502 20503 20504 20505 20506 20507 20508 20509 20510 20511 20512 20513\n [61] 20514 20515 20516 20517 20518 20519 20520 20521 20522 20523 20524 20525\n [73] 20526 20527 20528 20529 20530 20531 20532 20533 20534 20535 20536 20537\n [85] 20538 20539 20540 20541 20542 20543 20544 20545 20546 20547 20548 20549\n [97] 20550 20551 20552 20553 20554 20555 20556 20557 20558 20559 20560 20561\n[109] 20562 20563 20564 20565 20566 20567 20568 20569 20570 20571 20572 20573\n[121] 20574 20575 20576 20577 20578 20579 20580 20581 20582 20583 20584 20585\n[133] 20586 20587 20588 20589 20590 20591 20592 20593 20594 20595 20596 20597\n[145] 20598 20599 20600 20601 20602 20603 20604 20605 20606 20607 20608 20609\n[157] 20610 20611 20612 20613 20614 20615 20616 20617 20618 20619 20620 20621\n[169] 20622 20623 20624 20625 20626 20627 20628 20629 20630 20631 20632 20633\n[181] 20634 20635 20636 20637 20638 20639 20640 20641 20642 20643 20644 20645\n[193] 20646 20647 20648 20649 20650 20651 20652 20653 20654 20655 20656 20657\n[205] 20658 20659 20660 20661 20662 20663 20664 20665 20666 20667 20668 20669\n[217] 20670 20671 20672 20673 20674 20675 20676 20677 20678 20679 20680 20681\n[229] 20682 20683 20684 20685 20686 20687 20688 20689 20690 20691 20692 20693\n[241] 20694 20695 20696 20697 20698 20699 20700 20701 20702 20703 20704 20705\n[253] 20706 20707 20708 20709 20710 20711 20712 20713 20714 20715 20716 20717\n[265] 20718 20719 20720 20721 20722 20723 20724 20725 20726 20727 20728 20729\n[277] 20730 20731 20732 20733 20734 20735 20736 20737 20738 20739 20740 20741\n[289] 20742 20743 20744 20745 20746 20747 20748 20749 20750 20751 20752 20753\n[301] 20754 20755 20756 20757 20758 20759 20760 20761 20762 20763 20764 20765\n[313] 20766 20767 20768 20769 20770 20771 20772 20773 20774 20775 20411 20412\n[325] 20413 20414 20415 20416 20417 20418 20419 20420 20421 20422 20423 20424\n[337] 20425 20426 20427 20428 20429 20430 20431 20432 20433 20434 20435 20436\n[349] 20437 20438 20439 20440 20441 20442 20443 20444 20445 20446 20447 20448\n[361] 20449 20450 20451 20452 20453 20454\n\nCodeif_else(fun_dates &lt; today(), fun_dates + years(), fun_dates) # Good: keeps dates as dates\n\n  [1] \"2026-01-01\" \"2026-01-02\" \"2026-01-03\" \"2026-01-04\" \"2026-01-05\"\n  [6] \"2026-01-06\" \"2026-01-07\" \"2026-01-08\" \"2026-01-09\" \"2026-01-10\"\n [11] \"2026-01-11\" \"2026-01-12\" \"2026-01-13\" \"2026-01-14\" \"2026-01-15\"\n [16] \"2026-01-16\" \"2026-01-17\" \"2026-01-18\" \"2026-01-19\" \"2026-01-20\"\n [21] \"2026-01-21\" \"2026-01-22\" \"2026-01-23\" \"2026-01-24\" \"2026-01-25\"\n [26] \"2026-01-26\" \"2026-01-27\" \"2026-01-28\" \"2026-01-29\" \"2026-01-30\"\n [31] \"2026-01-31\" \"2026-02-01\" \"2026-02-02\" \"2026-02-03\" \"2026-02-04\"\n [36] \"2026-02-05\" \"2026-02-06\" \"2026-02-07\" \"2026-02-08\" \"2026-02-09\"\n [41] \"2026-02-10\" \"2026-02-11\" \"2026-02-12\" \"2026-02-13\" \"2026-02-14\"\n [46] \"2026-02-15\" \"2026-02-16\" \"2026-02-17\" \"2026-02-18\" \"2026-02-19\"\n [51] \"2026-02-20\" \"2026-02-21\" \"2026-02-22\" \"2026-02-23\" \"2026-02-24\"\n [56] \"2026-02-25\" \"2026-02-26\" \"2026-02-27\" \"2026-02-28\" \"2026-03-01\"\n [61] \"2026-03-02\" \"2026-03-03\" \"2026-03-04\" \"2026-03-05\" \"2026-03-06\"\n [66] \"2026-03-07\" \"2026-03-08\" \"2026-03-09\" \"2026-03-10\" \"2026-03-11\"\n [71] \"2026-03-12\" \"2026-03-13\" \"2026-03-14\" \"2026-03-15\" \"2026-03-16\"\n [76] \"2026-03-17\" \"2026-03-18\" \"2026-03-19\" \"2026-03-20\" \"2026-03-21\"\n [81] \"2026-03-22\" \"2026-03-23\" \"2026-03-24\" \"2026-03-25\" \"2026-03-26\"\n [86] \"2026-03-27\" \"2026-03-28\" \"2026-03-29\" \"2026-03-30\" \"2026-03-31\"\n [91] \"2026-04-01\" \"2026-04-02\" \"2026-04-03\" \"2026-04-04\" \"2026-04-05\"\n [96] \"2026-04-06\" \"2026-04-07\" \"2026-04-08\" \"2026-04-09\" \"2026-04-10\"\n[101] \"2026-04-11\" \"2026-04-12\" \"2026-04-13\" \"2026-04-14\" \"2026-04-15\"\n[106] \"2026-04-16\" \"2026-04-17\" \"2026-04-18\" \"2026-04-19\" \"2026-04-20\"\n[111] \"2026-04-21\" \"2026-04-22\" \"2026-04-23\" \"2026-04-24\" \"2026-04-25\"\n[116] \"2026-04-26\" \"2026-04-27\" \"2026-04-28\" \"2026-04-29\" \"2026-04-30\"\n[121] \"2026-05-01\" \"2026-05-02\" \"2026-05-03\" \"2026-05-04\" \"2026-05-05\"\n[126] \"2026-05-06\" \"2026-05-07\" \"2026-05-08\" \"2026-05-09\" \"2026-05-10\"\n[131] \"2026-05-11\" \"2026-05-12\" \"2026-05-13\" \"2026-05-14\" \"2026-05-15\"\n[136] \"2026-05-16\" \"2026-05-17\" \"2026-05-18\" \"2026-05-19\" \"2026-05-20\"\n[141] \"2026-05-21\" \"2026-05-22\" \"2026-05-23\" \"2026-05-24\" \"2026-05-25\"\n[146] \"2026-05-26\" \"2026-05-27\" \"2026-05-28\" \"2026-05-29\" \"2026-05-30\"\n[151] \"2026-05-31\" \"2026-06-01\" \"2026-06-02\" \"2026-06-03\" \"2026-06-04\"\n[156] \"2026-06-05\" \"2026-06-06\" \"2026-06-07\" \"2026-06-08\" \"2026-06-09\"\n[161] \"2026-06-10\" \"2026-06-11\" \"2026-06-12\" \"2026-06-13\" \"2026-06-14\"\n[166] \"2026-06-15\" \"2026-06-16\" \"2026-06-17\" \"2026-06-18\" \"2026-06-19\"\n[171] \"2026-06-20\" \"2026-06-21\" \"2026-06-22\" \"2026-06-23\" \"2026-06-24\"\n[176] \"2026-06-25\" \"2026-06-26\" \"2026-06-27\" \"2026-06-28\" \"2026-06-29\"\n[181] \"2026-06-30\" \"2026-07-01\" \"2026-07-02\" \"2026-07-03\" \"2026-07-04\"\n[186] \"2026-07-05\" \"2026-07-06\" \"2026-07-07\" \"2026-07-08\" \"2026-07-09\"\n[191] \"2026-07-10\" \"2026-07-11\" \"2026-07-12\" \"2026-07-13\" \"2026-07-14\"\n[196] \"2026-07-15\" \"2026-07-16\" \"2026-07-17\" \"2026-07-18\" \"2026-07-19\"\n[201] \"2026-07-20\" \"2026-07-21\" \"2026-07-22\" \"2026-07-23\" \"2026-07-24\"\n[206] \"2026-07-25\" \"2026-07-26\" \"2026-07-27\" \"2026-07-28\" \"2026-07-29\"\n[211] \"2026-07-30\" \"2026-07-31\" \"2026-08-01\" \"2026-08-02\" \"2026-08-03\"\n[216] \"2026-08-04\" \"2026-08-05\" \"2026-08-06\" \"2026-08-07\" \"2026-08-08\"\n[221] \"2026-08-09\" \"2026-08-10\" \"2026-08-11\" \"2026-08-12\" \"2026-08-13\"\n[226] \"2026-08-14\" \"2026-08-15\" \"2026-08-16\" \"2026-08-17\" \"2026-08-18\"\n[231] \"2026-08-19\" \"2026-08-20\" \"2026-08-21\" \"2026-08-22\" \"2026-08-23\"\n[236] \"2026-08-24\" \"2026-08-25\" \"2026-08-26\" \"2026-08-27\" \"2026-08-28\"\n[241] \"2026-08-29\" \"2026-08-30\" \"2026-08-31\" \"2026-09-01\" \"2026-09-02\"\n[246] \"2026-09-03\" \"2026-09-04\" \"2026-09-05\" \"2026-09-06\" \"2026-09-07\"\n[251] \"2026-09-08\" \"2026-09-09\" \"2026-09-10\" \"2026-09-11\" \"2026-09-12\"\n[256] \"2026-09-13\" \"2026-09-14\" \"2026-09-15\" \"2026-09-16\" \"2026-09-17\"\n[261] \"2026-09-18\" \"2026-09-19\" \"2026-09-20\" \"2026-09-21\" \"2026-09-22\"\n[266] \"2026-09-23\" \"2026-09-24\" \"2026-09-25\" \"2026-09-26\" \"2026-09-27\"\n[271] \"2026-09-28\" \"2026-09-29\" \"2026-09-30\" \"2026-10-01\" \"2026-10-02\"\n[276] \"2026-10-03\" \"2026-10-04\" \"2026-10-05\" \"2026-10-06\" \"2026-10-07\"\n[281] \"2026-10-08\" \"2026-10-09\" \"2026-10-10\" \"2026-10-11\" \"2026-10-12\"\n[286] \"2026-10-13\" \"2026-10-14\" \"2026-10-15\" \"2026-10-16\" \"2026-10-17\"\n[291] \"2026-10-18\" \"2026-10-19\" \"2026-10-20\" \"2026-10-21\" \"2026-10-22\"\n[296] \"2026-10-23\" \"2026-10-24\" \"2026-10-25\" \"2026-10-26\" \"2026-10-27\"\n[301] \"2026-10-28\" \"2026-10-29\" \"2026-10-30\" \"2026-10-31\" \"2026-11-01\"\n[306] \"2026-11-02\" \"2026-11-03\" \"2026-11-04\" \"2026-11-05\" \"2026-11-06\"\n[311] \"2026-11-07\" \"2026-11-08\" \"2026-11-09\" \"2026-11-10\" \"2026-11-11\"\n[316] \"2026-11-12\" \"2026-11-13\" \"2026-11-14\" \"2026-11-15\" \"2026-11-16\"\n[321] \"2026-11-17\" \"2026-11-18\" \"2025-11-19\" \"2025-11-20\" \"2025-11-21\"\n[326] \"2025-11-22\" \"2025-11-23\" \"2025-11-24\" \"2025-11-25\" \"2025-11-26\"\n[331] \"2025-11-27\" \"2025-11-28\" \"2025-11-29\" \"2025-11-30\" \"2025-12-01\"\n[336] \"2025-12-02\" \"2025-12-03\" \"2025-12-04\" \"2025-12-05\" \"2025-12-06\"\n[341] \"2025-12-07\" \"2025-12-08\" \"2025-12-09\" \"2025-12-10\" \"2025-12-11\"\n[346] \"2025-12-12\" \"2025-12-13\" \"2025-12-14\" \"2025-12-15\" \"2025-12-16\"\n[351] \"2025-12-17\" \"2025-12-18\" \"2025-12-19\" \"2025-12-20\" \"2025-12-21\"\n[356] \"2025-12-22\" \"2025-12-23\" \"2025-12-24\" \"2025-12-25\" \"2025-12-26\"\n[361] \"2025-12-27\" \"2025-12-28\" \"2025-12-29\" \"2025-12-30\" \"2025-12-31\"\n[366] \"2026-01-01\"\n\n\n\n\n\n\nExercises\nLoad the diamonds dataset, and filter to the first 1000 diamonds.\n\nCodedata(diamonds)\ndiamonds &lt;- diamonds |&gt; \n    slice_head(n = 1000)\n\n\nUsing tidyverse functions, complete the following:\n\nSubset to diamonds that are less than 400 dollars or more than 10000 dollars.\nSubset to diamonds that are between 500 and 600 dollars (inclusive).\nHow many diamonds are of either Fair, Premium, or Ideal cut (a total count)? What fraction of diamonds are of Fair, Premium, or Ideal cut?\n\nFirst, do this a wrong way with ==. Predict the warning message that you will receive.\nSecond, do this the correct way with an appropriate logical operator.\n\n\nAre there any diamonds of Fair cut that are more than $3000? Are all diamonds of Ideal cut more than $2000?\nCreate two new categorized versions of price by looking up the documentation for if_else() and case_when():\n\n\nprice_cat1: ‚Äúlow‚Äù if price is less than 500 and ‚Äúhigh‚Äù otherwise\n\nprice_cat2: ‚Äúlow‚Äù if price is less than 500, ‚Äúmedium‚Äù if price is between 500 and 1000 dollars inclusive, and ‚Äúhigh‚Äù otherwise.\n\n\n\n\nCode# 1\ndiamonds |&gt; \n    filter(price &lt; 400 | price &gt; 10000)\n\n# A tibble: 30 √ó 10\n   carat cut       color clarity depth table price     x     y     z\n   &lt;dbl&gt; &lt;ord&gt;     &lt;ord&gt; &lt;ord&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n 1  0.23 Ideal     E     SI2      61.5    55   326  3.95  3.98  2.43\n 2  0.21 Premium   E     SI1      59.8    61   326  3.89  3.84  2.31\n 3  0.23 Good      E     VS1      56.9    65   327  4.05  4.07  2.31\n 4  0.29 Premium   I     VS2      62.4    58   334  4.2   4.23  2.63\n 5  0.31 Good      J     SI2      63.3    58   335  4.34  4.35  2.75\n 6  0.24 Very Good J     VVS2     62.8    57   336  3.94  3.96  2.48\n 7  0.24 Very Good I     VVS1     62.3    57   336  3.95  3.98  2.47\n 8  0.26 Very Good H     SI1      61.9    55   337  4.07  4.11  2.53\n 9  0.22 Fair      E     VS2      65.1    61   337  3.87  3.78  2.49\n10  0.23 Very Good H     VS1      59.4    61   338  4     4.05  2.39\n# ‚Ñπ 20 more rows\n\nCode# 2\ndiamonds |&gt; \n    filter(price &gt;= 500, price &lt;= 600)\n\n# A tibble: 90 √ó 10\n   carat cut       color clarity depth table price     x     y     z\n   &lt;dbl&gt; &lt;ord&gt;     &lt;ord&gt; &lt;ord&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n 1  0.35 Ideal     I     VS1      60.9  57     552  4.54  4.59  2.78\n 2  0.3  Premium   D     SI1      62.6  59     552  4.23  4.27  2.66\n 3  0.3  Ideal     D     SI1      62.5  57     552  4.29  4.32  2.69\n 4  0.3  Ideal     D     SI1      62.1  56     552  4.3   4.33  2.68\n 5  0.42 Premium   I     SI2      61.5  59     552  4.78  4.84  2.96\n 6  0.28 Ideal     G     VVS2     61.4  56     553  4.19  4.22  2.58\n 7  0.32 Ideal     I     VVS1     62    55.3   553  4.39  4.42  2.73\n 8  0.31 Very Good G     SI1      63.3  57     553  4.33  4.3   2.73\n 9  0.31 Premium   G     SI1      61.8  58     553  4.35  4.32  2.68\n10  0.24 Premium   E     VVS1     60.7  58     553  4.01  4.03  2.44\n# ‚Ñπ 80 more rows\n\nCode# 3\n## Wrong way with ==\ndiamonds |&gt; \n    mutate(is_fpi = cut == c(\"Fair\", \"Premium\", \"Ideal\")) |&gt; \n    summarize(num_fpi = sum(is_fpi), frac_fpi = mean(is_fpi))\n\n# A tibble: 1 √ó 2\n  num_fpi frac_fpi\n    &lt;int&gt;    &lt;dbl&gt;\n1     226    0.226\n\nCode## Right way with %in%\ndiamonds |&gt; \n    mutate(is_fpi = cut %in% c(\"Fair\", \"Premium\", \"Ideal\")) |&gt; \n    summarize(num_fpi = sum(is_fpi), frac_fpi = mean(is_fpi))\n\n# A tibble: 1 √ó 2\n  num_fpi frac_fpi\n    &lt;int&gt;    &lt;dbl&gt;\n1     685    0.685\n\nCode# 4\ndiamonds |&gt; \n    filter(cut == \"Fair\") |&gt; \n    summarize(any_high = any(price &gt; 3000))\n\n# A tibble: 1 √ó 1\n  any_high\n  &lt;lgl&gt;   \n1 FALSE   \n\nCodediamonds |&gt; \n    filter(cut == \"Ideal\") |&gt; \n    summarize(all_high = all(price &gt; 2000))\n\n# A tibble: 1 √ó 1\n  all_high\n  &lt;lgl&gt;   \n1 FALSE   \n\nCode# 5\ndiamonds |&gt; \n    mutate(\n        price_cat1 = if_else(price &lt; 500, \"low\", \"high\"),\n        price_cat2 = case_when(\n            price &lt; 500 ~ \"low\",\n            price &gt;= 500 & price &lt;= 1000 ~ \"medium\",\n            price &gt; 1000 ~ \"high\"\n        )\n    )\n\n# A tibble: 1,000 √ó 12\n   carat cut       color clarity depth table price     x     y     z price_cat1\n   &lt;dbl&gt; &lt;ord&gt;     &lt;ord&gt; &lt;ord&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;     \n 1  0.23 Ideal     E     SI2      61.5    55   326  3.95  3.98  2.43 low       \n 2  0.21 Premium   E     SI1      59.8    61   326  3.89  3.84  2.31 low       \n 3  0.23 Good      E     VS1      56.9    65   327  4.05  4.07  2.31 low       \n 4  0.29 Premium   I     VS2      62.4    58   334  4.2   4.23  2.63 low       \n 5  0.31 Good      J     SI2      63.3    58   335  4.34  4.35  2.75 low       \n 6  0.24 Very Good J     VVS2     62.8    57   336  3.94  3.96  2.48 low       \n 7  0.24 Very Good I     VVS1     62.3    57   336  3.95  3.98  2.47 low       \n 8  0.26 Very Good H     SI1      61.9    55   337  4.07  4.11  2.53 low       \n 9  0.22 Fair      E     VS2      65.1    61   337  3.87  3.78  2.49 low       \n10  0.23 Very Good H     VS1      59.4    61   338  4     4.05  2.39 low       \n# ‚Ñπ 990 more rows\n# ‚Ñπ 1 more variable: price_cat2 &lt;chr&gt;",
    "crumbs": [
      "In-Class Activities",
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>6 Adv Data wrangling P1</span>"
    ]
  },
  {
    "objectID": "src/ica/06_adv_data_wrangling_p1/06-wrangling-1-notes.html#numerics",
    "href": "src/ica/06_adv_data_wrangling_p1/06-wrangling-1-notes.html#numerics",
    "title": "6 Adv Data wrangling P1",
    "section": "Numerics",
    "text": "Numerics\nNotes\nNumerical data can be of class integer or numeric (representing real numbers).\n\nCodex &lt;- 1:3\nx\n\n[1] 1 2 3\n\nCodeclass(x)\n\n[1] \"integer\"\n\nCodex &lt;- c(1+1e-9, 2, 3)\nx\n\n[1] 1 2 3\n\nCodeclass(x)\n\n[1] \"numeric\"\n\n\nThe Numbers chapter in R4DS covers the following functions that are all useful for wrangling numeric data:\n\n\nn(), n_distinct(): Counting and counting the number of unique values\n\nsum(is.na()): Counting the number of missing values\n\nmin(), max()\n\n\npmin(), pmax(): Get the min and max across several vectors\nInteger division: %/%. Remainder: %%\n\n\n121 %/% 100 = 1 and 121 %% 100 = 21\n\n\n\n\nround(), floor(), ceiling(): Rounding functions (to a specified number of decimal places, to the largest integer below a number, to the smallest integer above a number)\n\ncut(): Cut a numerical vector into categories\n\ncumsum(), cummean(), cummin(), cummax(): Cumulative functions\n\nrank(): Provide the ranks of the numbers in a vector\n\nlead(), lag(): shift a vector by padding with NAs\nNumerical summaries: mean, median, min, max, quantile, sd, IQR\n\nNote that all numerical summary functions have an na.rm argument that should be set to TRUE if you have missing data.\n\n\nExercises\nExercises will be on HW4.\nThe best way to add these functions and operators to your vocabulary is to need to recall them. Refer to the list of functions above as you try the exercises.\nYou will need to reference function documentation to look at arguments and look in the Examples section.",
    "crumbs": [
      "In-Class Activities",
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>6 Adv Data wrangling P1</span>"
    ]
  },
  {
    "objectID": "src/ica/06_adv_data_wrangling_p1/06-wrangling-1-notes.html#dates",
    "href": "src/ica/06_adv_data_wrangling_p1/06-wrangling-1-notes.html#dates",
    "title": "6 Adv Data wrangling P1",
    "section": "Dates",
    "text": "Dates\nNotes\nThe lubridate package contains useful functions for working with dates and times. The lubridate function reference is a useful resource for finding the functions you need. We‚Äôll take a brief tour of this reference page.\nWe‚Äôll use the lakers dataset in the lubridate package to illustrate some examples.\n\nCodelakers &lt;- as_tibble(lakers)\nhead(lakers)\n\n# A tibble: 6 √ó 13\n     date opponent game_type time  period etype team  player result points type \n    &lt;int&gt; &lt;chr&gt;    &lt;chr&gt;     &lt;chr&gt;  &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;   &lt;int&gt; &lt;chr&gt;\n1  2.01e7 POR      home      12:00      1 jump‚Ä¶ OFF   \"\"     \"\"          0 \"\"   \n2  2.01e7 POR      home      11:39      1 shot  LAL   \"Pau ‚Ä¶ \"miss‚Ä¶      0 \"hoo‚Ä¶\n3  2.01e7 POR      home      11:37      1 rebo‚Ä¶ LAL   \"Vlad‚Ä¶ \"\"          0 \"off\"\n4  2.01e7 POR      home      11:25      1 shot  LAL   \"Dere‚Ä¶ \"miss‚Ä¶      0 \"lay‚Ä¶\n5  2.01e7 POR      home      11:23      1 rebo‚Ä¶ LAL   \"Pau ‚Ä¶ \"\"          0 \"off\"\n6  2.01e7 POR      home      11:22      1 shot  LAL   \"Pau ‚Ä¶ \"made\"      2 \"hoo‚Ä¶\n# ‚Ñπ 2 more variables: x &lt;int&gt;, y &lt;int&gt;\n\n\nBelow we use date-time parsing functions to represent the date and time variables with date-time classes:\n\nCodelakers &lt;- lakers |&gt;\n    mutate(\n        date = ymd(date),\n        time = ms(time)\n    )\n\n\nBelow we use extraction functions to get components of the date-time objects:\n\nCodelakers_clean &lt;- lakers |&gt;\n    mutate(\n        year = year(date),\n        month = month(date),\n        day = day(date),\n        day_of_week = wday(date, label = TRUE),\n        minute = minute(time),\n        second = second(time)\n    )\nlakers_clean |&gt; select(year:second)\n\n# A tibble: 34,624 √ó 6\n    year month   day day_of_week minute second\n   &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;ord&gt;        &lt;dbl&gt;  &lt;dbl&gt;\n 1  2008    10    28 Tue             12      0\n 2  2008    10    28 Tue             11     39\n 3  2008    10    28 Tue             11     37\n 4  2008    10    28 Tue             11     25\n 5  2008    10    28 Tue             11     23\n 6  2008    10    28 Tue             11     22\n 7  2008    10    28 Tue             11     22\n 8  2008    10    28 Tue             11     22\n 9  2008    10    28 Tue             11      0\n10  2008    10    28 Tue             10     53\n# ‚Ñπ 34,614 more rows\n\nCodelakers_clean &lt;- lakers_clean |&gt;\n    group_by(date, opponent, period) |&gt;\n    arrange(date, opponent, period, desc(time)) |&gt;\n    mutate(\n        diff_btw_plays_sec = as.numeric(time - lag(time, 1))\n    )\nlakers_clean |&gt; select(date, opponent, time, period, diff_btw_plays_sec)\n\n# A tibble: 34,624 √ó 5\n# Groups:   date, opponent, period [314]\n   date       opponent time     period diff_btw_plays_sec\n   &lt;date&gt;     &lt;chr&gt;    &lt;Period&gt;  &lt;int&gt;              &lt;dbl&gt;\n 1 2008-10-28 POR      12M 0S        1                 NA\n 2 2008-10-28 POR      11M 39S       1                -21\n 3 2008-10-28 POR      11M 37S       1                 -2\n 4 2008-10-28 POR      11M 25S       1                -12\n 5 2008-10-28 POR      11M 23S       1                 -2\n 6 2008-10-28 POR      11M 22S       1                 -1\n 7 2008-10-28 POR      11M 22S       1                  0\n 8 2008-10-28 POR      11M 22S       1                  0\n 9 2008-10-28 POR      11M 0S        1                -22\n10 2008-10-28 POR      10M 53S       1                 -7\n# ‚Ñπ 34,614 more rows\n\n\nExercises\nExercises will be on HW4.",
    "crumbs": [
      "In-Class Activities",
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>6 Adv Data wrangling P1</span>"
    ]
  },
  {
    "objectID": "src/ica/06_adv_data_wrangling_p1/06-wrangling-1-notes.html#factors",
    "href": "src/ica/06_adv_data_wrangling_p1/06-wrangling-1-notes.html#factors",
    "title": "6 Adv Data wrangling P1",
    "section": "Factors",
    "text": "Factors\nNotes\nCreating factors\nIn R, factors are made up of two components: the actual values of the data and the possible levels within the factor. Creating a factor requires supplying both pieces of information.\n\nCodemonths &lt;- c(\"Mar\", \"Dec\", \"Jan\",  \"Apr\", \"Jul\")\n\n\nHowever, if we were to sort this vector, R would sort this vector alphabetically.\n\nCode# alphabetical sort\nsort(months)\n\n[1] \"Apr\" \"Dec\" \"Jan\" \"Jul\" \"Mar\"\n\n\nWe can fix this sorting by creating a factor version of months. The levels argument is a character vector that specifies the unique values that the factor can take. The order of the values in levels defines the sorting of the factor.\n\nCodemonths_fct &lt;- factor(months, levels = month.abb) # month.abb is a built-in variable\nmonths_fct\n\n[1] Mar Dec Jan Apr Jul\nLevels: Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\n\nCodesort(months_fct)\n\n[1] Jan Mar Apr Jul Dec\nLevels: Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\n\n\nWhat if we try to create a factor with values that aren‚Äôt in the levels? (e.g., a typo in a month name)\n\nCodemonths2 &lt;- c(\"Jna\", \"Mar\")\nfactor(months2, levels = month.abb)\n\n[1] &lt;NA&gt; Mar \nLevels: Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\n\n\nBecause the NA is introduced silently (without any error or warnings), this can be dangerous. It might be better to use the fct() function in the forcats package instead:\n\nCodefct(months2, levels = month.abb)\n\nError in `fct()`:\n! All values of `x` must appear in `levels` or `na`\n‚Ñπ Missing level: \"Jna\"\n\n\nReordering factors\nWe‚Äôll use a subset of the General Social Survey (GSS) dataset available in the forcats pacakges.\n\nCodedata(gss_cat)\nhead(gss_cat)\n\n# A tibble: 6 √ó 9\n   year marital         age race  rincome        partyid     relig denom tvhours\n  &lt;int&gt; &lt;fct&gt;         &lt;int&gt; &lt;fct&gt; &lt;fct&gt;          &lt;fct&gt;       &lt;fct&gt; &lt;fct&gt;   &lt;int&gt;\n1  2000 Never married    26 White $8000 to 9999  Ind,near r‚Ä¶ Prot‚Ä¶ Sout‚Ä¶      12\n2  2000 Divorced         48 White $8000 to 9999  Not str re‚Ä¶ Prot‚Ä¶ Bapt‚Ä¶      NA\n3  2000 Widowed          67 White Not applicable Independent Prot‚Ä¶ No d‚Ä¶       2\n4  2000 Never married    39 White Not applicable Ind,near r‚Ä¶ Orth‚Ä¶ Not ‚Ä¶       4\n5  2000 Divorced         25 White Not applicable Not str de‚Ä¶ None  Not ‚Ä¶       1\n6  2000 Married          25 White $20000 - 24999 Strong dem‚Ä¶ Prot‚Ä¶ Sout‚Ä¶      NA\n\n\nReordering the levels of a factor can be useful in plotting when categories would benefit from being sorted in a particular way:\n\nCoderelig_summary &lt;- gss_cat |&gt;\n    group_by(relig) |&gt;\n    summarize(\n        tvhours = mean(tvhours, na.rm = TRUE),\n        n = n()\n    )\n\nggplot(relig_summary, aes(x = tvhours, y = relig)) + \n    geom_point() +\n    theme_classic()\n\n\n\n\n\n\n\nWe can use fct_reorder() in forcats.\n\nThe first argument is the factor that you want to reorder the levels of\nThe second argument determines how the factor is sorted (analogous to what you put inside arrange() when sorting the rows of a data frame.)\n\n\nCodeggplot(relig_summary, aes(x = tvhours, y = fct_reorder(relig, tvhours))) +\n    geom_point() +\n    theme_classic()\n\n\n\n\n\n\n\nFor bar plots, we can use fct_infreq() to reorder levels from most to least common. This can be combined with fct_rev() to reverse the order (least to most common):\n\nCodegss_cat |&gt;\n    ggplot(aes(x = marital)) +\n    geom_bar() +\n    theme_classic()\n\n\n\n\n\n\nCodegss_cat |&gt;\n    mutate(marital = marital |&gt; fct_infreq() |&gt; fct_rev()) |&gt;\n    ggplot(aes(x = marital)) +\n    geom_bar() +\n    theme_classic()\n\n\n\n\n\n\n\nModifying factor levels\nWe talked about reordering the levels of a factor‚Äìwhat about changing the values of the levels themselves?\nFor example, the names of the political parties in the GSS could use elaboration (‚Äústr‚Äù isn‚Äôt a great label for ‚Äústrong‚Äù) and clean up:\n\nCodegss_cat |&gt; count(partyid)\n\n# A tibble: 10 √ó 2\n   partyid                n\n   &lt;fct&gt;              &lt;int&gt;\n 1 No answer            154\n 2 Don't know             1\n 3 Other party          393\n 4 Strong republican   2314\n 5 Not str republican  3032\n 6 Ind,near rep        1791\n 7 Independent         4119\n 8 Ind,near dem        2499\n 9 Not str democrat    3690\n10 Strong democrat     3490\n\n\nWe can use fct_recode() on partyid with the new level names going on the left and the old levels on the right. Any levels that aren‚Äôt mentioned explicitly (i.e., ‚ÄúDon‚Äôt know‚Äù and ‚ÄúOther party‚Äù) will be left as is:\n\nCodegss_cat |&gt;\n    mutate(\n        partyid = fct_recode(partyid,\n            \"Republican, strong\"    = \"Strong republican\",\n            \"Republican, weak\"      = \"Not str republican\",\n            \"Independent, near rep\" = \"Ind,near rep\",\n            \"Independent, near dem\" = \"Ind,near dem\",\n            \"Democrat, weak\"        = \"Not str democrat\",\n            \"Democrat, strong\"      = \"Strong democrat\"\n        )\n    ) |&gt;\n    count(partyid)\n\n# A tibble: 10 √ó 2\n   partyid                   n\n   &lt;fct&gt;                 &lt;int&gt;\n 1 No answer               154\n 2 Don't know                1\n 3 Other party             393\n 4 Republican, strong     2314\n 5 Republican, weak       3032\n 6 Independent, near rep  1791\n 7 Independent            4119\n 8 Independent, near dem  2499\n 9 Democrat, weak         3690\n10 Democrat, strong       3490\n\n\nTo combine groups, we can assign multiple old levels to the same new level (‚ÄúOther‚Äù maps to ‚ÄúNo answer‚Äù, ‚ÄúDon‚Äôt know‚Äù, and ‚ÄúOther party‚Äù):\n\nCodegss_cat |&gt;\n    mutate(\n        partyid = fct_recode(partyid,\n            \"Republican, strong\"    = \"Strong republican\",\n            \"Republican, weak\"      = \"Not str republican\",\n            \"Independent, near rep\" = \"Ind,near rep\",\n            \"Independent, near dem\" = \"Ind,near dem\",\n            \"Democrat, weak\"        = \"Not str democrat\",\n            \"Democrat, strong\"      = \"Strong democrat\",\n            \"Other\"                 = \"No answer\",\n            \"Other\"                 = \"Don't know\",\n            \"Other\"                 = \"Other party\"\n        )\n    )\n\n# A tibble: 21,483 √ó 9\n    year marital         age race  rincome        partyid    relig denom tvhours\n   &lt;int&gt; &lt;fct&gt;         &lt;int&gt; &lt;fct&gt; &lt;fct&gt;          &lt;fct&gt;      &lt;fct&gt; &lt;fct&gt;   &lt;int&gt;\n 1  2000 Never married    26 White $8000 to 9999  Independe‚Ä¶ Prot‚Ä¶ Sout‚Ä¶      12\n 2  2000 Divorced         48 White $8000 to 9999  Republica‚Ä¶ Prot‚Ä¶ Bapt‚Ä¶      NA\n 3  2000 Widowed          67 White Not applicable Independe‚Ä¶ Prot‚Ä¶ No d‚Ä¶       2\n 4  2000 Never married    39 White Not applicable Independe‚Ä¶ Orth‚Ä¶ Not ‚Ä¶       4\n 5  2000 Divorced         25 White Not applicable Democrat,‚Ä¶ None  Not ‚Ä¶       1\n 6  2000 Married          25 White $20000 - 24999 Democrat,‚Ä¶ Prot‚Ä¶ Sout‚Ä¶      NA\n 7  2000 Never married    36 White $25000 or more Republica‚Ä¶ Chri‚Ä¶ Not ‚Ä¶       3\n 8  2000 Divorced         44 White $7000 to 7999  Independe‚Ä¶ Prot‚Ä¶ Luth‚Ä¶      NA\n 9  2000 Married          44 White $25000 or more Democrat,‚Ä¶ Prot‚Ä¶ Other       0\n10  2000 Married          47 White $25000 or more Republica‚Ä¶ Prot‚Ä¶ Sout‚Ä¶       3\n# ‚Ñπ 21,473 more rows\n\n\nWe can use fct_collapse() to collapse many levels:\n\nCodegss_cat |&gt;\n    mutate(\n        partyid = fct_collapse(partyid,\n            \"Other\" = c(\"No answer\", \"Don't know\", \"Other party\"),\n            \"Republican\" = c(\"Strong republican\", \"Not str republican\"),\n            \"Independent\" = c(\"Ind,near rep\", \"Independent\", \"Ind,near dem\"),\n            \"Democrat\" = c(\"Not str democrat\", \"Strong democrat\")\n        )\n    ) |&gt;\n    count(partyid)\n\n# A tibble: 4 √ó 2\n  partyid         n\n  &lt;fct&gt;       &lt;int&gt;\n1 Other         548\n2 Republican   5346\n3 Independent  8409\n4 Democrat     7180\n\n\nExercises\n\nCreate a factor version of the following data with the levels in a sensible order.\n\n\nCoderatings &lt;- c(\"High\", \"Medium\", \"Low\")\n\n\nMore exercises will be on HW4.",
    "crumbs": [
      "In-Class Activities",
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>6 Adv Data wrangling P1</span>"
    ]
  },
  {
    "objectID": "src/ica/06_adv_data_wrangling_p1/06-wrangling-1-notes.html#done",
    "href": "src/ica/06_adv_data_wrangling_p1/06-wrangling-1-notes.html#done",
    "title": "6 Adv Data wrangling P1",
    "section": "Done!",
    "text": "Done!\n\nCheck the ICA Instructions for how to (a) push your code to GitHub and (b) update your portfolio website\n\n\nCodepaste0(\"Letter of the Day: \",letters)\n\n [1] \"Letter of the Day: a\" \"Letter of the Day: b\" \"Letter of the Day: c\"\n [4] \"Letter of the Day: d\" \"Letter of the Day: e\" \"Letter of the Day: f\"\n [7] \"Letter of the Day: g\" \"Letter of the Day: h\" \"Letter of the Day: i\"\n[10] \"Letter of the Day: j\" \"Letter of the Day: k\" \"Letter of the Day: l\"\n[13] \"Letter of the Day: m\" \"Letter of the Day: n\" \"Letter of the Day: o\"\n[16] \"Letter of the Day: p\" \"Letter of the Day: q\" \"Letter of the Day: r\"\n[19] \"Letter of the Day: s\" \"Letter of the Day: t\" \"Letter of the Day: u\"\n[22] \"Letter of the Day: v\" \"Letter of the Day: w\" \"Letter of the Day: x\"\n[25] \"Letter of the Day: y\" \"Letter of the Day: z\"\n\nCodestr_c(\"Letter of the Day:\",letters, collapse = '')\n\n[1] \"Letter of the Day:aLetter of the Day:bLetter of the Day:cLetter of the Day:dLetter of the Day:eLetter of the Day:fLetter of the Day:gLetter of the Day:hLetter of the Day:iLetter of the Day:jLetter of the Day:kLetter of the Day:lLetter of the Day:mLetter of the Day:nLetter of the Day:oLetter of the Day:pLetter of the Day:qLetter of the Day:rLetter of the Day:sLetter of the Day:tLetter of the Day:uLetter of the Day:vLetter of the Day:wLetter of the Day:xLetter of the Day:yLetter of the Day:z\"\n\nCodestr_c(\"Letter of the Day: \",letters, sep = '')\n\n [1] \"Letter of the Day: a\" \"Letter of the Day: b\" \"Letter of the Day: c\"\n [4] \"Letter of the Day: d\" \"Letter of the Day: e\" \"Letter of the Day: f\"\n [7] \"Letter of the Day: g\" \"Letter of the Day: h\" \"Letter of the Day: i\"\n[10] \"Letter of the Day: j\" \"Letter of the Day: k\" \"Letter of the Day: l\"\n[13] \"Letter of the Day: m\" \"Letter of the Day: n\" \"Letter of the Day: o\"\n[16] \"Letter of the Day: p\" \"Letter of the Day: q\" \"Letter of the Day: r\"\n[19] \"Letter of the Day: s\" \"Letter of the Day: t\" \"Letter of the Day: u\"\n[22] \"Letter of the Day: v\" \"Letter of the Day: w\" \"Letter of the Day: x\"\n[25] \"Letter of the Day: y\" \"Letter of the Day: z\"\n\nCodestr_c(\"Letter of the Day: \",letters, collapse = '')\n\n[1] \"Letter of the Day: aLetter of the Day: bLetter of the Day: cLetter of the Day: dLetter of the Day: eLetter of the Day: fLetter of the Day: gLetter of the Day: hLetter of the Day: iLetter of the Day: jLetter of the Day: kLetter of the Day: lLetter of the Day: mLetter of the Day: nLetter of the Day: oLetter of the Day: pLetter of the Day: qLetter of the Day: rLetter of the Day: sLetter of the Day: tLetter of the Day: uLetter of the Day: vLetter of the Day: wLetter of the Day: xLetter of the Day: yLetter of the Day: z\"\n\nCodestr_flatten(letters,', ')\n\n[1] \"a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z\"",
    "crumbs": [
      "In-Class Activities",
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>6 Adv Data wrangling P1</span>"
    ]
  },
  {
    "objectID": "src/ica/09-functions-notes.html",
    "href": "src/ica/09-functions-notes.html",
    "title": "9 Functions",
    "section": "",
    "text": "üß© Learning Goals\nBy the end of this lesson, you should be able to:",
    "crumbs": [
      "In-Class Activities",
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>9 Functions</span>"
    ]
  },
  {
    "objectID": "src/ica/09-functions-notes.html#learning-goals",
    "href": "src/ica/09-functions-notes.html#learning-goals",
    "title": "9 Functions",
    "section": "",
    "text": "Recognize when it would be useful to write a function\nIdentify the core components of a function definition and explain their role (the function() directive, arguments, argument defaults, function body, return value)\nIdentify the scoping of a function in accessing objects in R\nDescribe the difference between argument matching by position and by name\nWrite if-else, if-else if-else statements to conditionally execute code\nWrite your own function to carry out a repeated task\nProvide feedback on functions written by others",
    "crumbs": [
      "In-Class Activities",
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>9 Functions</span>"
    ]
  },
  {
    "objectID": "src/ica/09-functions-notes.html#functions-and-control-structures",
    "href": "src/ica/09-functions-notes.html#functions-and-control-structures",
    "title": "9 Functions",
    "section": "Functions and Control Structures",
    "text": "Functions and Control Structures\nWhy functions?\nGetting really good at writing useful and reusable functions is one of the best ways to increase your expertise in data science. It requires a lot of practice.\nIf you‚Äôve copied and pasted code 3 or more times, it‚Äôs time to write a function. Try to avoid repeating yourself.\n\n\n\nReducing errors: Copy + paste + modify is prone to errors (e.g., forgetting to change a variable name)\n\nEfficiency: If you need to update code, you only need to do it one place. This allows reuse of code within and across projects.\n\nReadability: Encapsulating code within a function with a descriptive name makes code more readable.\n\n\nCore parts of a function\nWhen you define a function, what does it look like?\n\nCodelibrary(dplyr)\n# Defining a function\nfunction_name &lt;- function(input_name_1, input_name_2 = default_value_2){\n\n  # function body - code that does something\n\n  return(output)\n}\n\n# Calling a function (all valid ways)\nfunction_name(input_name_1 = 2, input_name_2 = 4)\nfunction_name(2, 4)\nfunction_name(input_name_2 = 4, input_name_1 = 2)\nfunction_name(2)\n\n\nThe core parts of defining a function include:\n\n\nfunction() directive\n\nThis is what allows tells R to create a function.\n\n\n\nArguments/Inputs: the input_name_1 and input_name_2 ‚Äì these are names of the function inputs\n\n\ndefault_value_2 is a default value that is used if no input values are provided when the function is called\n\n\n\nFunction body\n\nThe code inside the curly braces { } is where all the work happens. This code uses the function arguments to perform computations.\n\n\n\nReturn value\n\nWe can explicitly return an object by putting it inside return().\n\n\n\nHere are three examples that can help us learn a few properties of functions:\n\nCodeaverage &lt;- function(x, remove_nas) {\n    return(sum(x, na.rm = remove_nas)/length(x))\n}\naverage2 &lt;- function(x, remove_nas = TRUE) {\n    return(sum(x, na.rm = remove_nas)/length(x))\n}\n\naverage3 &lt;- function(x, remove_nas) {\n    sum(x, na.rm = remove_nas)/length(x)\n}\n\n\nNote:\n\nIn average2, the remove_nas argument has a default value of TRUE.\n\nWhen a function has default values for arguments, they don‚Äôt have to be provided when you call the function if you want to use the default value. See below:\n\nCode# Does throw an error\n# average(c(1, 2, 3, NA))\n# average(c(1, 2, 3, NA), remove_nas = TRUE)\n\n# Doesn't throw an error\naverage2(c(1, 2, 3, NA))\n\n[1] 1.5\n\nCodeaverage2(c(1, 2, 3, NA), remove_nas = FALSE)\n\n[1] NA\n\n\n\nIf we don‚Äôt provide a return(), the last value that gets evaluated in the function body and isn‚Äôt stored as an object is what the function returns. (This is generally the last line without an assignment operator &lt;-.)\n\n\naverage3() is one example, but this can easily lead to errors.\nWe should explicitly return an object by putting it inside return().",
    "crumbs": [
      "In-Class Activities",
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>9 Functions</span>"
    ]
  },
  {
    "objectID": "src/ica/09-functions-notes.html#scope",
    "href": "src/ica/09-functions-notes.html#scope",
    "title": "9 Functions",
    "section": "Scope",
    "text": "Scope\nIn programming, scope refers to the area of a program where a named object is recognized and can be used.\n\nR uses lexical scoping, which means that the scope of a variable is determined by where it is created in the code.\n\nLexical scoping in R:\n\nWhen code refers to an object (e.g.¬†data set, function, vector, etc.), R looks for the object in the current, local environment.\nIf it doesn‚Äôt find it, it continues to search by looking in the parent environment, and so on. The top-level environment is the global environment, the location where all interactive (i.e.¬†outside of a function) computation and storage takes place.\n\nIf you save an object in R, outside a function local environment, it is stored in the global environment.\n\n\nIf R can‚Äôt find it in the global environment, it will look for it in loaded packages.\n\nWhen writing and using functions, the local environment is within the function itself.\n\nIf you define an object in the function, it won‚Äôt be accessible outside that function (unless you pass it as the output). See below:\n\n\nCodeaverage_new &lt;- function(x, remove_nas = TRUE) {\n  sum(x, na.rm = remove_nas)/length(x)\n  fun_new_thing_within_function &lt;- \"Fun times!\"\n}\naverage_new(1:3)\nfun_new_thing_within_function\n\nError: object 'fun_new_thing_within_function' not found\n\n\nScoping is important to consider if you try to refer to objects that aren‚Äôt passed as arguments.\n\nThis can be dangerous because if you re-use names of variables, it is easy to accidentally refer to a variable that is not the one you intended. See below:\n\n\nCodev &lt;- c(1,2,3)\n\naverage_new2 &lt;- function(x, remove_nas = TRUE) {\n    sum(x, na.rm = remove_nas)/length(x) + v\n}\n\n\naverage_new2(1:3)\n\n[1] 3 4 5\n\nCodev &lt;- c(4,5,6)\naverage_new2(1:3)\n\n[1] 6 7 8\n\n\nAnything created/saved/updated within a function that you want accessible outside that function needs to be passed to return(). See below:\n\nCodev &lt;- c(1,2,3)\n\naverage_new3 &lt;- function(x, remove_nas = TRUE) {\n  v &lt;- v + 10 # this is not changing v outside the function... \n  return(sum(x, na.rm = remove_nas)/length(x) )\n}\n\naverage_new3(1:3)\n\n[1] 2\n\nCodev\n\n[1] 1 2 3\n\n\nFor more about lexical scoping in R, see R Programming for Data Science",
    "crumbs": [
      "In-Class Activities",
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>9 Functions</span>"
    ]
  },
  {
    "objectID": "src/ica/09-functions-notes.html#writing-functions",
    "href": "src/ica/09-functions-notes.html#writing-functions",
    "title": "9 Functions",
    "section": "Writing Functions",
    "text": "Writing Functions\nTips for writing functions:\n\nWrite the code for the body of the function (the task that you are wanting to repeat)\nIdentify the parts of the function that could/would change (these are the inputs)\n\nUpdate the body of the function to be in terms of the inputs\nAvoid manually typing anything that is specific to one input; use code to get that (such as unique values of a variable)\n\n\nIdentify the output you want to return\n\nPair programming exercises: There are 2 exercises for each section below.\n\nRead through the introduction of the concept and then work on the exercises together.\n\nYou‚Äôll swap driver and navigator roles between exercises.\nRemember: The driver writes the code. The navigator oversees and provides guidance.\nFor the first exercise, the person whose birthday is coming up sooner will be the driver first. Swap role for the second exercise and continue in this manner for all exercises.\n\n\n\nRescaling function Write a function that rescales a numeric vector to be between 0 and 1. Here are some test cases with the expected output. Test out your function on the following inputs:\n\n\n\nx = 2:4. Expected output: 0.0 0.5 1.0\n\n\nx = c(-1, 0, 5). Expected output: 0.0000000 0.1666667 1.0000000\n\n\nx = -3:-1. Expected output: 0.0 0.5 1.0\n\n\n\n\nPhone digits Write a function that formats a 10-digit phone number nicely as (###) ###-####. Your function should work on the following test cases: c(\"651-330-8661\", \"6516966000\", \"800 867 5309\"). It may help to refer to the stringr cheatsheet.",
    "crumbs": [
      "In-Class Activities",
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>9 Functions</span>"
    ]
  },
  {
    "objectID": "src/ica/09-functions-notes.html#calling-a-function",
    "href": "src/ica/09-functions-notes.html#calling-a-function",
    "title": "9 Functions",
    "section": "Calling a Function",
    "text": "Calling a Function\nWhen you supply arguments to a function, they can be matched by position and/or by name.\nWhen you call a function without argument = value inside the parentheses, you are using positional matching.\n\nCodeggplot(diamonds, aes(x = carat, y = price)) + geom_point()\n\n\nThe above works because the first argument of ggplot is data and the second is mapping. (Pull up the documentation on ggplot with ?ggplot in the Console.) So the following doesn‚Äôt work:\n\nCodeggplot(aes(x = carat, y = price), diamonds) + geom_point()\n\nError in `ggplot()`:\n! `mapping` must be created with `aes()`.\n‚úñ You've supplied a tibble.\n\n\nBut if we named the arguments (name matching), we would be fine:\n\nCodeggplot(mapping = aes(x = carat, y = price), data = diamonds) + geom_point()\n\n\nSomewhat confusingly, we can name some arguments and not others. Below, mapping is named, but data isn‚Äôt. This works because when an argument is matched by name, it is ‚Äúremoved‚Äù from the argument list, and the remaining unnamed arguments are matched in the order that they are listed in the function definition. Just because this is possible doesn‚Äôt mean it‚Äôs a good idea‚Äìdon‚Äôt do this!\n\nCodeggplot(mapping = aes(x = carat, y = price), diamonds) + geom_point()\n\n\n\n\n\n\n\n\nArgument matching\n\n\n\nIn general, it is safest to match arguments by name and position for your peace of mind. For functions that you are very familiar with (and know the argument order), it‚Äôs ok to just use positional matching.\n\n\n\n\nError Messages Diagnose the error message in the example below:\n\nggplot() |&gt;\n    geom_sf(census_data, aes(fill = population))\n    \nError in `layer_sf()`:\n! `mapping` must be created by `aes()`",
    "crumbs": [
      "In-Class Activities",
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>9 Functions</span>"
    ]
  },
  {
    "objectID": "src/ica/09-functions-notes.html#the-if-else-if-else-control-structure",
    "href": "src/ica/09-functions-notes.html#the-if-else-if-else-control-structure",
    "title": "9 Functions",
    "section": "The if-else if-else Control Structure",
    "text": "The if-else if-else Control Structure\nOften in functions, you will want to execute code chunks conditionally. In a programming language, control structures are parts of the language that allow you to control what code is executed. By far the most common is the `if-else if-else structure.\n\nCodeif (logical_condition) {\n    # some code\n} else if (other_logical_condition) {\n    # some code\n} else {\n    # some code\n}\n\nmiddle &lt;- function(x) {\n    mean_x &lt;- mean(x, na.rm = TRUE)\n    median_x &lt;- median(x, na.rm = TRUE)\n    seems_skewed &lt;- (mean_x &gt; 1.5*median_x) | (mean_x &lt; (1/1.5)*median_x)\n    if (seems_skewed) {\n        median_x\n    } else {\n        mean_x\n    }\n}\n\n\n\n\n\n\n\n\nTo vectorize or not to vectorize\n\n\n\nThe if () else {} code is not vectorized; the logical condition in if() cannot be a logical vector of length longer than 1. If you want a vectorized version of conditional execution of code use if_else() or case_when(); these can be used in mutate().\n\n\n\n\nConvert Temp Write a function for converting temperatures that takes as input a numeric value and a unit (either ‚ÄúC‚Äù for Celsius or ‚ÄúF‚Äù for Fahrenheit). The function should convert the temperature from one unit to the other based on the following formulas:\n\n\nTo convert Celsius to Fahrenheit: (Celsius * 9/5) + 32\n\nTo convert Fahrenheit to Celsius: (Fahrenheit - 32) * 5/9\n\n\n\n\nDomain Name Write a function that extracts the domain name of a supplied email address. The function should return the domain name (e.g., ‚Äúgmail.com‚Äù). If the input is not a valid email address, return ‚ÄúInvalid Email‚Äù. (A valid email ends in ‚Äúdot something‚Äù.)",
    "crumbs": [
      "In-Class Activities",
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>9 Functions</span>"
    ]
  },
  {
    "objectID": "src/ica/09-functions-notes.html#writing-functions-with-tidyverse-verbs",
    "href": "src/ica/09-functions-notes.html#writing-functions-with-tidyverse-verbs",
    "title": "9 Functions",
    "section": "Writing Functions with tidyverse Verbs",
    "text": "Writing Functions with tidyverse Verbs\nPerhaps we are using group_by() and summarize() a lot to compute group means. We might write this function:\n\nCodegroup_means &lt;- function(df, group_var, mean_var) {\n    df |&gt;\n        group_by(group_var) |&gt;\n        summarize(mean = mean(mean_var))\n}\n\n\nLet‚Äôs use it on the diamonds dataset to compute the mean size (carat) by diamond cut:\n\nCodegroup_means(diamonds, group_var = cut, mean_var = carat)\n\nError in `group_by()`:\n! Must group by variables found in `.data`.\n‚úñ Column `group_var` is not found.\n\n\nWhat if the problem is that the variable names need to be in quotes?\n\nCodegroup_means(diamonds, group_var = \"cut\", mean_var = \"carat\")\n\nError in `group_by()`:\n! Must group by variables found in `.data`.\n‚úñ Column `group_var` is not found.\n\n\nWhat‚Äôs Going On?\nThe tidyverse uses something called tidy evaluation: this allows you to refer to a variable by typing it directly (e.g., no need to put it in quotes).\n\n\ngroup_by(group_var) is expecting a variable that is actually called group_var, and mean(mean_var) is expecting a variable that is actually called mean_var.\n\nTo fix this we need to embrace the variables inside the function with { var }:\n\nCodegroup_means &lt;- function(df, group_var, mean_var) {\n    df |&gt;\n        group_by({{ group_var }}) |&gt;\n        summarize(mean = mean({{ mean_var }}))\n}\n\n\nThe { var } tells R to look at what the variable specified by the input var rather than look for a variable called var.\n\nCodegroup_means(diamonds, group_var = cut, mean_var = carat)\n\n# A tibble: 5 √ó 2\n  cut        mean\n  &lt;ord&gt;     &lt;dbl&gt;\n1 Fair      1.05 \n2 Good      0.849\n3 Very Good 0.806\n4 Premium   0.892\n5 Ideal     0.703\n\n\nLet‚Äôs group by both cut and color:\n\nCodegroup_means(diamonds, group_var = c(cut, color), mean_var = carat)\n\nError in `group_by()`:\n‚Ñπ In argument: `c(cut, color)`.\nCaused by error:\n! `c(cut, color)` must be size 53940 or 1, not 107880.\n\n\nOh No! What Now?!\nWhen c(cut, color) is put inside { c(cut, color) } within the function, R is actually running the code inside { }.\n\nThis combines the columns for those 2 variables into one long vector. What we really meant by c(cut, color) is ‚Äúgroup by both cut and color‚Äù.\n\nTo fix this, we need the pick() function to get R to see { group_var } as a vector of separate variables (like the way select() works).\n\nCodegroup_means &lt;- function(df, group_var, mean_var) {\n    df |&gt;\n        group_by(pick({{ group_var }})) |&gt;\n        summarize(mean = mean({{ mean_var }}))\n}\n\n\n\n\nProp function Create a new version of dplyr::count() that also shows proportions instead of just sample sizes. The function should be able to handle counting by multiple variables. Test your function with two different sets of arguments using the diamonds dataset.\n\n\n\nScatterplot + Smooth function Create a function that creates a scatterplot from a user-supplied dataset with user-supplied x and y variables. The plot should also show a curvy smoothing line in blue, and a linear smoothing line in red. Test your function using the diamonds dataset.",
    "crumbs": [
      "In-Class Activities",
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>9 Functions</span>"
    ]
  },
  {
    "objectID": "src/ica/09-functions-notes.html#done",
    "href": "src/ica/09-functions-notes.html#done",
    "title": "9 Functions",
    "section": "Done!",
    "text": "Done!\n\nCheck the ICA Instructions for how to (a) push your code to GitHub and (b) update your portfolio website",
    "crumbs": [
      "In-Class Activities",
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>9 Functions</span>"
    ]
  },
  {
    "objectID": "src/ica/10-base-r-notes.html",
    "href": "src/ica/10-base-r-notes.html",
    "title": "10 Base R",
    "section": "",
    "text": "üß© Learning Goals\nBy the end of this lesson, you should be able to:",
    "crumbs": [
      "In-Class Activities",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>10 Base R</span>"
    ]
  },
  {
    "objectID": "src/ica/10-base-r-notes.html#learning-goals",
    "href": "src/ica/10-base-r-notes.html#learning-goals",
    "title": "10 Base R",
    "section": "",
    "text": "Identify and define the properties of common structures in R\nSubset vectors and lists with [ by index, name, logical vector, and indirectly with objects\nSubset data frames and lists with $ and [[\n\nUse the str() function to examine the structure of an unfamiliar object and extract components from the object\nApply printing strategies to streamline the debugging and development process",
    "crumbs": [
      "In-Class Activities",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>10 Base R</span>"
    ]
  },
  {
    "objectID": "src/ica/10-base-r-notes.html#common-r-object-structures",
    "href": "src/ica/10-base-r-notes.html#common-r-object-structures",
    "title": "10 Base R",
    "section": "Common R Object Structures",
    "text": "Common R Object Structures\nVector: A vector is a collection of elements of the same type (e.g., numeric, integer, character, logical).\n\nCodenum_vec &lt;- vector(\"numeric\", length = 2) #empty vector: Zeros\nnum_vec\n\n[1] 0 0\n\nCodeclass(num_vec)\n\n[1] \"numeric\"\n\nCodelength(num_vec)\n\n[1] 2\n\n\n\nCodelog_vec &lt;- vector(\"logical\", length = 3) #empty vector: FALSE\nlog_vec\n\n[1] FALSE FALSE FALSE\n\nCodeclass(log_vec)\n\n[1] \"logical\"\n\nCodelength(log_vec)\n\n[1] 3\n\n\n\nCodechr_vec &lt;- vector(\"character\", length = 4) #empty vector: empty strings\nchr_vec\n\n[1] \"\" \"\" \"\" \"\"\n\nCodeclass(chr_vec)\n\n[1] \"character\"\n\nCodelength(chr_vec)\n\n[1] 4\n\n\n\nFun Fact: A vector can have names for each of its elements.\n\n\nCodenamed_vec &lt;- c('name1' = 1, 'name2' = 2) # Named numeric vector\nnamed_vec\n\nname1 name2 \n    1     2 \n\nCodeclass(named_vec)\n\n[1] \"numeric\"\n\nCodelength(named_vec)\n\n[1] 2\n\n\nList: A list is a collection of elements (e.g., vectors, matrices, data frames, other lists).\n\nA list can have different types of elements.\nA list can have names for its elements.\n\n\nCodeex_list &lt;- list(a = 1:3, b = c(\"a\", \"b\", \"c\"), c = matrix(1:6, nrow = 2))\nex_list\n\n$a\n[1] 1 2 3\n\n$b\n[1] \"a\" \"b\" \"c\"\n\n$c\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\nCodeclass(ex_list)\n\n[1] \"list\"\n\nCodelength(ex_list) # number of elements in a list\n\n[1] 3",
    "crumbs": [
      "In-Class Activities",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>10 Base R</span>"
    ]
  },
  {
    "objectID": "src/ica/10-base-r-notes.html#other-common-r-object-structures",
    "href": "src/ica/10-base-r-notes.html#other-common-r-object-structures",
    "title": "10 Base R",
    "section": "Other Common R Object Structures",
    "text": "Other Common R Object Structures\nArray: An array is a vector with a dimension attribute.\n\nLike a vector, an array can only have one type of data (e.g., numeric, character).\n\n\nCodeary &lt;- array(NA, dim = c(2,3,4))\nary\n\n, , 1\n\n     [,1] [,2] [,3]\n[1,]   NA   NA   NA\n[2,]   NA   NA   NA\n\n, , 2\n\n     [,1] [,2] [,3]\n[1,]   NA   NA   NA\n[2,]   NA   NA   NA\n\n, , 3\n\n     [,1] [,2] [,3]\n[1,]   NA   NA   NA\n[2,]   NA   NA   NA\n\n, , 4\n\n     [,1] [,2] [,3]\n[1,]   NA   NA   NA\n[2,]   NA   NA   NA\n\nCodeclass(ary)\n\n[1] \"array\"\n\nCodelength(ary) # The number of elements in a array is the product of its dimensions\n\n[1] 24\n\nCodedim(ary) # Get the dimensions of the array\n\n[1] 2 3 4\n\n\nMatrix: A matrix is an array with only 2 dimensions (rows, columns).\n\nLike a vector, a matrix can only have one type of data (e.g., numeric, character).\n\n\nCodem &lt;- matrix(NA, nrow = 2, ncol = 3)\nm\n\n     [,1] [,2] [,3]\n[1,]   NA   NA   NA\n[2,]   NA   NA   NA\n\nCodeclass(m)\n\n[1] \"matrix\" \"array\" \n\nCodelength(m) # The number of elements in a matrix is the product of its dimensions\n\n[1] 6\n\nCodedim(m) # Get the dimensions of the matrix\n\n[1] 2 3\n\n\nData Frame/tibble: A data frame is a named list with elements of equal length.\n\nEach element is a ‚Äúcolumn‚Äù in the data frame.\nThe columns can be of different types (e.g., character, numeric, logical, lists, etc.).\nData frames are the most common way to store data in R.\nTibbles do less and complain more than base data.frames\n\n\nCodemod_df &lt;- tibble(x = 1:10, y = 1:10 + rnorm(10))\n\ndf &lt;- tibble(a = 1:3, b = c(\"constant\", \"x\", \"x squared\"), d = list(lm(y ~ 1, data = mod_df), lm(y ~ x, data = mod_df), lm(y ~ x + I(x^2), data = mod_df)))\ndf\n\n# A tibble: 3 √ó 3\n      a b         d     \n  &lt;int&gt; &lt;chr&gt;     &lt;list&gt;\n1     1 constant  &lt;lm&gt;  \n2     2 x         &lt;lm&gt;  \n3     3 x squared &lt;lm&gt;  \n\nCodelength(df) # number of \"elements\" in a data frame is the number of \"columns\"\n\n[1] 3",
    "crumbs": [
      "In-Class Activities",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>10 Base R</span>"
    ]
  },
  {
    "objectID": "src/ica/10-base-r-notes.html#base-r-subsetting",
    "href": "src/ica/10-base-r-notes.html#base-r-subsetting",
    "title": "10 Base R",
    "section": "Base R Subsetting",
    "text": "Base R Subsetting\nThe content here comes from Chapter 27 of R4DS, with some small additions.",
    "crumbs": [
      "In-Class Activities",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>10 Base R</span>"
    ]
  },
  {
    "objectID": "src/ica/10-base-r-notes.html#selecting-elements-with",
    "href": "src/ica/10-base-r-notes.html#selecting-elements-with",
    "title": "10 Base R",
    "section": "Selecting elements with [\n",
    "text": "Selecting elements with [\n\nWe can subset common R structures and maintain the class structure with [ ].\nThere are four main types of things that you can subset with, i.e., that can be the i in x[i]:\n\n\nA vector of positive integers. Subsetting with positive integers keeps the elements at those positions:\n\n\nCode# Vectors\nx &lt;- c(\"one\", \"two\", \"three\", \"four\", \"five\")\nx[c(3, 2, 5)]\n\n[1] \"three\" \"two\"   \"five\" \n\nCodex[2:4]\n\n[1] \"two\"   \"three\" \"four\" \n\nCodeclass(x[2:4]) # result is a character vector\n\n[1] \"character\"\n\n\n\nCode# Lists\ny &lt;- list(a = 1:3, b = c(\"a\", \"b\", \"c\"), c = matrix(1:6, nrow = 2))\ny[c(1, 2)]\n\n$a\n[1] 1 2 3\n\n$b\n[1] \"a\" \"b\" \"c\"\n\nCodeclass(y[c(1)]) # result is a list\n\n[1] \"list\"\n\n\nBy repeating a position, you can actually make a longer output than input, making the term ‚Äúsubsetting‚Äù a bit of a misnomer.\n\nCode# Vector\nx[c(1, 1, 2)]\n\n[1] \"one\" \"one\" \"two\"\n\nCode# List\ny[c(1, 1, 2)]\n\n$a\n[1] 1 2 3\n\n$a\n[1] 1 2 3\n\n$b\n[1] \"a\" \"b\" \"c\"\n\n\n\n\nA vector of negative integers. Negative values drop the elements at the specified positions:\n\n\nCode# Vector\nx[c(-1, -3, -5)]\n\n[1] \"two\"  \"four\"\n\nCode# List\ny[c(-1)]\n\n$b\n[1] \"a\" \"b\" \"c\"\n\n$c\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\n\n\n\nA logical vector. Subsetting with a logical vector only keeps values corresponding to TRUE. This is generally used with comparison functions and operators.\n\n\nCode# Vector\nx &lt;- c(10, 3, NA, 5, 8, 1, NA)\n\n# All non-missing values of x\nx[!is.na(x)]\n\n[1] 10  3  5  8  1\n\nCode# All values greater than 5, with NAs\nx[x &gt; 5]\n\n[1] 10 NA  8 NA\n\nCode# All non-missing values greater than 5\nx[x &gt; 5 & !is.na(x)]\n\n[1] 10  8\n\n\nUnlike filter(), NA indices will be included in the output as NAs unless you explicitly remove them (filter() removes instances of missing values by default.\n\nCode# Compare with filter \nfilter(tibble(x = x), x &gt; 5)\n\n# A tibble: 2 √ó 1\n      x\n  &lt;dbl&gt;\n1    10\n2     8\n\n\n\nCode# List\ny[c(TRUE, FALSE, TRUE)]\n\n$a\n[1] 1 2 3\n\n$c\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\nCodey[y |&gt; map_lgl(~ is.numeric(.x))] # example of a map function!\n\n$a\n[1] 1 2 3\n\n$c\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\nCodey[y |&gt; map_lgl(~ is.character(.x))]\n\n$b\n[1] \"a\" \"b\" \"c\"\n\n\n\n\nA character vector. If you have a named vector or list, you can subset it with a character vector:\n\n\nCode# Named Vector\nx &lt;- c(abc = 1, def = 2, xyz = 5)\nx[c(\"xyz\", \"def\")]\n\nxyz def \n  5   2 \n\nCodex[c(\"xyz\",\"xyz\",\"xyz\", \"def\")]\n\nxyz xyz xyz def \n  5   5   5   2 \n\nCode#Named List\ny[c('a','a','c')]\n\n$a\n[1] 1 2 3\n\n$a\n[1] 1 2 3\n\n$c\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\n\nAs with subsetting with positive integers, you can use a character vector to duplicate individual entries.\nBe very wary of vector recycling when doing this! The number of things that you‚Äôre inserting should either be 1 or the size of the x[i] subset.\n\nCodex &lt;- c(first = \"one\", second = \"two\", third = \"three\", fourth = \"four\")\nx\n\n  first  second   third  fourth \n  \"one\"   \"two\" \"three\"  \"four\" \n\n\n\nCodex[c(1, 3)] &lt;- \"new\" # Replacement length is 1\nx\n\n first second  third fourth \n \"new\"  \"two\"  \"new\" \"four\" \n\n\n\nCodex &lt;- c(first = \"one\", second = \"two\", third = \"three\", fourth = \"four\")\nx[c(1, 3)] &lt;- c(\"new1\", \"new2\") # Replacement length is 2, and length of subset is 2\nx\n\n first second  third fourth \n\"new1\"  \"two\" \"new2\" \"four\" \n\n\n\nCodex &lt;- c(first = \"one\", second = \"two\", third = \"three\", fourth = \"four\")\nx[c(1, 3, 4)] &lt;- c(\"new1\", \"new2\") # BAD! Replacement length is 2, and length of subset is 3\nx\n\n first second  third fourth \n\"new1\"  \"two\" \"new2\" \"new1\" \n\n\n\nCodex &lt;- c(first = \"one\", second = \"two\", third = \"three\", fourth = \"four\")\nx[c(1, 3)] &lt;- c(\"new1\", \"new2\", \"new3\") # BAD! Replacement length is 3, and length of subset is 2\nx\n\n first second  third fourth \n\"new1\"  \"two\" \"new2\" \"four\"",
    "crumbs": [
      "In-Class Activities",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>10 Base R</span>"
    ]
  },
  {
    "objectID": "src/ica/10-base-r-notes.html#subsetting-matricies-and-data-frames-with",
    "href": "src/ica/10-base-r-notes.html#subsetting-matricies-and-data-frames-with",
    "title": "10 Base R",
    "section": "Subsetting Matricies and Data Frames with [\n",
    "text": "Subsetting Matricies and Data Frames with [\n\nAll of the above subsetting options can be used for subsetting matrices and data frames (named list of elements of equal length).\n\nCodem &lt;- matrix(1:12, nrow = 3, ncol = 4)\nm\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    4    7   10\n[2,]    2    5    8   11\n[3,]    3    6    9   12\n\nCodem[1:5] # Matrix = vector (down the columns) with dimensions\n\n[1] 1 2 3 4 5\n\n\nYou can use a comma to subset by rows and columns separately.\n\nCodem[1,] # Get 1st row\n\n[1]  1  4  7 10\n\nCodem[,1] # Get 1st column\n\n[1] 1 2 3\n\n\n. . .\n\nCodem[1,3] # Get 1st row and 3rd column\n\n[1] 7\n\nCodem[c(1,3),] # Get 1st and 3rd rows\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    4    7   10\n[2,]    3    6    9   12\n\nCodem[,c(1,3)] # Get 1st and 3rd columns\n\n     [,1] [,2]\n[1,]    1    7\n[2,]    2    8\n[3,]    3    9\n\nCodem[c(1,3),c(1,3)] # Get 1st and 3rd rows and 1st and 3rd columns\n\n     [,1] [,2]\n[1,]    1    7\n[2,]    3    9\n\nCodem[-1,] # Get all rows except 1st\n\n     [,1] [,2] [,3] [,4]\n[1,]    2    5    8   11\n[2,]    3    6    9   12\n\nCodem[c(TRUE, FALSE, FALSE),] # Get the 1st row via a logical\n\n[1]  1  4  7 10\n\nCode# Add row and column names to the matrix\ncolnames(m) &lt;- str_c(\"col\", 1:4)\nrownames(m) &lt;- str_c(\"row\", 1:3)\nm[\"row1\",]\n\ncol1 col2 col3 col4 \n   1    4    7   10",
    "crumbs": [
      "In-Class Activities",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>10 Base R</span>"
    ]
  },
  {
    "objectID": "src/ica/10-base-r-notes.html#selecting-a-single-element-with-and",
    "href": "src/ica/10-base-r-notes.html#selecting-a-single-element-with-and",
    "title": "10 Base R",
    "section": "Selecting a single element with $ and [[\n",
    "text": "Selecting a single element with $ and [[\n\nWe can use $ and [[ to extract a single column of a data frame or an element within a list. This breaks out of the original class structure.\n\nCodemtcars\n\n                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nMazda RX4           21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag       21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710          22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2\nValiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1\nDuster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4\nMerc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\nMerc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\nMerc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\nMerc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4\nMerc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3\nMerc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3\nMerc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3\nCadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4\nLincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4\nChrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4\nFiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\nHonda Civic         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\nToyota Corolla      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\nToyota Corona       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\nDodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2\nAMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2\nCamaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4\nPontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2\nFiat X1-9           27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\nPorsche 914-2       26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\nLotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\nFord Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4\nFerrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6\nMaserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8\nVolvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n\nCodemtcars$mpg\n\n [1] 21.0 21.0 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 17.8 16.4 17.3 15.2 10.4\n[16] 10.4 14.7 32.4 30.4 33.9 21.5 15.5 15.2 13.3 19.2 27.3 26.0 30.4 15.8 19.7\n[31] 15.0 21.4\n\nCodemtcars[[\"mpg\"]]\n\n [1] 21.0 21.0 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 17.8 16.4 17.3 15.2 10.4\n[16] 10.4 14.7 32.4 30.4 33.9 21.5 15.5 15.2 13.3 19.2 27.3 26.0 30.4 15.8 19.7\n[31] 15.0 21.4\n\nCodemtcars |&gt; pull(mpg)\n\n [1] 21.0 21.0 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 17.8 16.4 17.3 15.2 10.4\n[16] 10.4 14.7 32.4 30.4 33.9 21.5 15.5 15.2 13.3 19.2 27.3 26.0 30.4 15.8 19.7\n[31] 15.0 21.4",
    "crumbs": [
      "In-Class Activities",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>10 Base R</span>"
    ]
  },
  {
    "objectID": "src/ica/10-base-r-notes.html#exercises",
    "href": "src/ica/10-base-r-notes.html#exercises",
    "title": "10 Base R",
    "section": "Exercises",
    "text": "Exercises\n\n\nSubsetting Functions For each of the tasks below, write a function that take a vector as input returns the desired output:\n\n\nThe elements at even-numbered positions. (Hint: use the seq() function.)\n\n\nCodeget_even_pos &lt;- function(x) {\n  if (length(x) &lt;= 1) {\n    print(\"no even positions\")\n  } else {\n    i &lt;- seq(2, length(x), by = 2)\n    x[i]\n  }\n}\n\nget_even_pos(1:10)\n\n[1]  2  4  6  8 10\n\n\n\nEvery element except the last value.\n\n\nCodeno_last_value &lt;- function(x) {\n  head(x, -1)\n}\nno_last_value(1:10)\n\n[1] 1 2 3 4 5 6 7 8 9\n\n\n\nOnly even values (and no missing values).\n\n\nCodeonly_even_no_missing &lt;- function(x) {\n  x[x %/% 2 == 0 & !is.na(x)]\n}\n\nonly_even_no_missing(c(1, 2, 3, 4, NA))\n\n[1] 1",
    "crumbs": [
      "In-Class Activities",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>10 Base R</span>"
    ]
  },
  {
    "objectID": "src/ica/10-base-r-notes.html#exploring-the-structure-of-an-object-with-str",
    "href": "src/ica/10-base-r-notes.html#exploring-the-structure-of-an-object-with-str",
    "title": "10 Base R",
    "section": "Exploring the structure of an object with str()\n",
    "text": "Exploring the structure of an object with str()\n\nThe str() function shows you the structure of an object and is useful for exploring model objects and objects created from packages that are new to you.\nIn the output of str() dollar signs indicate named components of a list that can be extracted via $ or [[.\n. . .\nWe see that both mod and mod_summ are lists, so we can also interactively view these objects with View(mod) and View(mod_summ) in the Console.\n\nCodemod &lt;- lm(mpg ~ hp + wt, data = mtcars)\nmod_summ &lt;- summary(mod)\n\nstr(mod)\n\nList of 12\n $ coefficients : Named num [1:3] 37.2273 -0.0318 -3.8778\n  ..- attr(*, \"names\")= chr [1:3] \"(Intercept)\" \"hp\" \"wt\"\n $ residuals    : Named num [1:32] -2.572 -1.583 -2.476 0.135 0.373 ...\n  ..- attr(*, \"names\")= chr [1:32] \"Mazda RX4\" \"Mazda RX4 Wag\" \"Datsun 710\" \"Hornet 4 Drive\" ...\n $ effects      : Named num [1:32] -113.65 -26.046 -15.894 0.447 0.662 ...\n  ..- attr(*, \"names\")= chr [1:32] \"(Intercept)\" \"hp\" \"wt\" \"\" ...\n $ rank         : int 3\n $ fitted.values: Named num [1:32] 23.6 22.6 25.3 21.3 18.3 ...\n  ..- attr(*, \"names\")= chr [1:32] \"Mazda RX4\" \"Mazda RX4 Wag\" \"Datsun 710\" \"Hornet 4 Drive\" ...\n $ assign       : int [1:3] 0 1 2\n $ qr           :List of 5\n  ..$ qr   : num [1:32, 1:3] -5.657 0.177 0.177 0.177 0.177 ...\n  .. ..- attr(*, \"dimnames\")=List of 2\n  .. .. ..$ : chr [1:32] \"Mazda RX4\" \"Mazda RX4 Wag\" \"Datsun 710\" \"Hornet 4 Drive\" ...\n  .. .. ..$ : chr [1:3] \"(Intercept)\" \"hp\" \"wt\"\n  .. ..- attr(*, \"assign\")= int [1:3] 0 1 2\n  ..$ qraux: num [1:3] 1.18 1.08 1.09\n  ..$ pivot: int [1:3] 1 2 3\n  ..$ tol  : num 1e-07\n  ..$ rank : int 3\n  ..- attr(*, \"class\")= chr \"qr\"\n $ df.residual  : int 29\n $ xlevels      : Named list()\n $ call         : language lm(formula = mpg ~ hp + wt, data = mtcars)\n $ terms        :Classes 'terms', 'formula'  language mpg ~ hp + wt\n  .. ..- attr(*, \"variables\")= language list(mpg, hp, wt)\n  .. ..- attr(*, \"factors\")= int [1:3, 1:2] 0 1 0 0 0 1\n  .. .. ..- attr(*, \"dimnames\")=List of 2\n  .. .. .. ..$ : chr [1:3] \"mpg\" \"hp\" \"wt\"\n  .. .. .. ..$ : chr [1:2] \"hp\" \"wt\"\n  .. ..- attr(*, \"term.labels\")= chr [1:2] \"hp\" \"wt\"\n  .. ..- attr(*, \"order\")= int [1:2] 1 1\n  .. ..- attr(*, \"intercept\")= int 1\n  .. ..- attr(*, \"response\")= int 1\n  .. ..- attr(*, \".Environment\")=&lt;environment: R_GlobalEnv&gt; \n  .. ..- attr(*, \"predvars\")= language list(mpg, hp, wt)\n  .. ..- attr(*, \"dataClasses\")= Named chr [1:3] \"numeric\" \"numeric\" \"numeric\"\n  .. .. ..- attr(*, \"names\")= chr [1:3] \"mpg\" \"hp\" \"wt\"\n $ model        :'data.frame':  32 obs. of  3 variables:\n  ..$ mpg: num [1:32] 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...\n  ..$ hp : num [1:32] 110 110 93 110 175 105 245 62 95 123 ...\n  ..$ wt : num [1:32] 2.62 2.88 2.32 3.21 3.44 ...\n  ..- attr(*, \"terms\")=Classes 'terms', 'formula'  language mpg ~ hp + wt\n  .. .. ..- attr(*, \"variables\")= language list(mpg, hp, wt)\n  .. .. ..- attr(*, \"factors\")= int [1:3, 1:2] 0 1 0 0 0 1\n  .. .. .. ..- attr(*, \"dimnames\")=List of 2\n  .. .. .. .. ..$ : chr [1:3] \"mpg\" \"hp\" \"wt\"\n  .. .. .. .. ..$ : chr [1:2] \"hp\" \"wt\"\n  .. .. ..- attr(*, \"term.labels\")= chr [1:2] \"hp\" \"wt\"\n  .. .. ..- attr(*, \"order\")= int [1:2] 1 1\n  .. .. ..- attr(*, \"intercept\")= int 1\n  .. .. ..- attr(*, \"response\")= int 1\n  .. .. ..- attr(*, \".Environment\")=&lt;environment: R_GlobalEnv&gt; \n  .. .. ..- attr(*, \"predvars\")= language list(mpg, hp, wt)\n  .. .. ..- attr(*, \"dataClasses\")= Named chr [1:3] \"numeric\" \"numeric\" \"numeric\"\n  .. .. .. ..- attr(*, \"names\")= chr [1:3] \"mpg\" \"hp\" \"wt\"\n - attr(*, \"class\")= chr \"lm\"\n\nCodestr(mod_summ)\n\nList of 11\n $ call         : language lm(formula = mpg ~ hp + wt, data = mtcars)\n $ terms        :Classes 'terms', 'formula'  language mpg ~ hp + wt\n  .. ..- attr(*, \"variables\")= language list(mpg, hp, wt)\n  .. ..- attr(*, \"factors\")= int [1:3, 1:2] 0 1 0 0 0 1\n  .. .. ..- attr(*, \"dimnames\")=List of 2\n  .. .. .. ..$ : chr [1:3] \"mpg\" \"hp\" \"wt\"\n  .. .. .. ..$ : chr [1:2] \"hp\" \"wt\"\n  .. ..- attr(*, \"term.labels\")= chr [1:2] \"hp\" \"wt\"\n  .. ..- attr(*, \"order\")= int [1:2] 1 1\n  .. ..- attr(*, \"intercept\")= int 1\n  .. ..- attr(*, \"response\")= int 1\n  .. ..- attr(*, \".Environment\")=&lt;environment: R_GlobalEnv&gt; \n  .. ..- attr(*, \"predvars\")= language list(mpg, hp, wt)\n  .. ..- attr(*, \"dataClasses\")= Named chr [1:3] \"numeric\" \"numeric\" \"numeric\"\n  .. .. ..- attr(*, \"names\")= chr [1:3] \"mpg\" \"hp\" \"wt\"\n $ residuals    : Named num [1:32] -2.572 -1.583 -2.476 0.135 0.373 ...\n  ..- attr(*, \"names\")= chr [1:32] \"Mazda RX4\" \"Mazda RX4 Wag\" \"Datsun 710\" \"Hornet 4 Drive\" ...\n $ coefficients : num [1:3, 1:4] 37.22727 -0.03177 -3.87783 1.59879 0.00903 ...\n  ..- attr(*, \"dimnames\")=List of 2\n  .. ..$ : chr [1:3] \"(Intercept)\" \"hp\" \"wt\"\n  .. ..$ : chr [1:4] \"Estimate\" \"Std. Error\" \"t value\" \"Pr(&gt;|t|)\"\n $ aliased      : Named logi [1:3] FALSE FALSE FALSE\n  ..- attr(*, \"names\")= chr [1:3] \"(Intercept)\" \"hp\" \"wt\"\n $ sigma        : num 2.59\n $ df           : int [1:3] 3 29 3\n $ r.squared    : num 0.827\n $ adj.r.squared: num 0.815\n $ fstatistic   : Named num [1:3] 69.2 2 29\n  ..- attr(*, \"names\")= chr [1:3] \"value\" \"numdf\" \"dendf\"\n $ cov.unscaled : num [1:3, 1:3] 3.80e-01 2.21e-05 -1.09e-01 2.21e-05 1.21e-05 ...\n  ..- attr(*, \"dimnames\")=List of 2\n  .. ..$ : chr [1:3] \"(Intercept)\" \"hp\" \"wt\"\n  .. ..$ : chr [1:3] \"(Intercept)\" \"hp\" \"wt\"\n - attr(*, \"class\")= chr \"summary.lm\"",
    "crumbs": [
      "In-Class Activities",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>10 Base R</span>"
    ]
  },
  {
    "objectID": "src/ica/10-base-r-notes.html#exercise",
    "href": "src/ica/10-base-r-notes.html#exercise",
    "title": "10 Base R",
    "section": "Exercise",
    "text": "Exercise\n\n\nCI Function Write a function that fits a linear model on the dataset using the given outcome and predictor variables and return a data frame (tibble) with the coefficient estimate and CI for the predictor of interest. It should take the following inputs:\n\n\n\ndata: A dataset\n\nyvar: Outcome variable to be used in a linear model (a length-1 character vector)\n\npreds: Predictor variables to be used in a linear model (a character vector)\n\npred_of_interest: The variable whose coefficient estimate and confidence interval are of interest (a length-1 character vector and should be one of preds)\n\nDevelopment tip: As you develop, it will help to create objects for the arguments so that you can see what output looks like interactively:\nTest your function on the mtcars dataset.\n\nCodedata &lt;- mtcars\nyvar &lt;- \"mpg\"\npreds &lt;- c(\"hp\", \"wt\")\npred_of_interest &lt;- \"hp\"\n\n\nWhen you‚Äôre done developing your function, remove these objects to declutter your environment by entering rm(data, yvar, preds, pred_of_interest) in the Console.\n\nCodefit_mod_and_extract &lt;- function(x) {\n    # Use str_c to create a string (formula_str) that looks like \"yvar ~ pred1 + pred2\"\n    # Look at the documentation for a helpful argument\n    mod_formula_str &lt;- str_c(yvar, \"~\", str_c(preds, collapse = \"+\"))\n    mod_form &lt;- as.formula(mod_formula_str)\n    \n    # Fit a linear model using the constructed formula and given data\n    mod &lt;- lm(mod_form, data = data)\n    \n    \n    # Obtain 95% confidence interval\n    ci &lt;- confint(mod, level = 0.95)\n    \n    # Return the coefficient estimate and CI for the predictor of interest\n    tibble(\n        which_pred = pred_of_interest,\n        estimate = mod$coefficients[pred_of_interest],\n        ci_lower = ci[pred_of_interest, \"2.5%\"],\n        ci_upper = ci[pred_of_interest, \"97.5%\"]\n    )\n}",
    "crumbs": [
      "In-Class Activities",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>10 Base R</span>"
    ]
  },
  {
    "objectID": "src/ica/10-base-r-notes.html#debugging-strategies",
    "href": "src/ica/10-base-r-notes.html#debugging-strategies",
    "title": "10 Base R",
    "section": "Debugging Strategies",
    "text": "Debugging Strategies\nWhen writing functions and working with functions that you wrote, you may encounter errors that are hard to figure out.\nHere are some strategies to help you debug the issues you encounter:\n\nUse print() and cat() to print out intermediate results and messages within a function.\n\nExamples: print(x), cat(\"The value of x is\", x, \"\\n\")\n\n\n\n\n\nCodeMy_own_sum &lt;- function(x){\n  print(x)\n  return(sum(x))\n}\nMy_own_sum(c(1,2,3))\n\nMy_own_sum &lt;- function(x){\n  cat(\"The value of x is\", x, \"\\n\")\n  cat(\"The class of x is\", class(x), \"\\n\")\n  return(sum(x))\n}\n\nMy_own_sum(c(1,2,3))\n\n\n\nUse browser() to pause the function at a certain point and interactively explore the environment. Press ‚ÄúNext‚Äù or type n to run the next line of code. Type the name of an object in the Console to see its value at this point in the function. You can type Q to quit the browser.\n\nExample below:\n\n\n\n\nCodefit_mod_and_extract &lt;- function(data, yvar, preds, pred_of_interest) {\n    # Use str_c to create a string (formula_str) that looks like \"yvar ~ pred1 + pred2\"\n    # Look at the documentation for a helpful argument\n    mod_formula_str &lt;- str_c(yvar, \"~\", str_c(preds, collapse = \"+\"))\n    mod_form &lt;- as.formula(mod_formula_str)\n    \n    # Add browser() to where in the function you'd like to pause and interact in the function environment using the Console\n    browser()\n    \n    # Fit a linear model using the constructed formula and given data\n    mod &lt;- lm(mod_form, data = data)\n    \n    # Obtain 95% confidence interval\n    ci &lt;- confint(mod, level = 0.95)\n    \n    # Return the coefficient estimate and CI for the predictor of interest\n    tibble(\n        which_pred = pred_of_interest,\n        estimate = mod$coefficients[pred_of_interest],\n        ci_lower = ci[pred_of_interest, \"2.5 %\"],\n        ci_upper = ci[pred_of_interest, \"97.5 %\"]\n    )\n}\n\n\nfit_mod_and_extract(data = mtcars, yvar = \"mpg\", preds = c(\"hp\", \"wt\"), pred_of_interest = \"hp\")\n\n\n\nUse try() to catch errors and print out a message when an error occurs.\n\nExample below:\n\n\n\n\nCodeMy_own_sum &lt;- function(x){\n  return(sum(x))\n}\n\nresults &lt;- My_own_sum(c(\"a\",\"b\",\"c\"))\n\nError in sum(x): invalid 'type' (character) of argument\n\nCodeclass(results)\n\nError: object 'results' not found\n\nCoderesults &lt;- try(My_own_sum(c(\"a\",\"b\",\"c\")), silent = TRUE)\nclass(results)\n\n[1] \"try-error\"\n\n\n\nInclude if else statements within a function to ensure that you are passing the right type of input to a function. You can create you own custom error message with stop().\n\nExample below:\n\n\n\n\nCodeMy_own_sum &lt;- function(x){\n  if(!is.numeric(x)){\n    stop(\"Input must be numeric\")\n  }\n  return(sum(x))\n}\n\nresults &lt;- My_own_sum(c(\"a\",\"b\",\"c\"))\n\nError in My_own_sum(c(\"a\", \"b\", \"c\")): Input must be numeric\n\nCodeclass(results)\n\n[1] \"try-error\"\n\nCoderesults &lt;- try(My_own_sum(c(\"a\",\"b\",\"c\")), silent = TRUE)\nclass(results)\n\n[1] \"try-error\"",
    "crumbs": [
      "In-Class Activities",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>10 Base R</span>"
    ]
  },
  {
    "objectID": "src/ica/10-base-r-notes.html#done",
    "href": "src/ica/10-base-r-notes.html#done",
    "title": "10 Base R",
    "section": "Done!",
    "text": "Done!\n\nCheck the ICA Instructions for how to (a) push your code to GitHub and (b) update your portfolio website",
    "crumbs": [
      "In-Class Activities",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>10 Base R</span>"
    ]
  },
  {
    "objectID": "src/exam/exam1.html",
    "href": "src/exam/exam1.html",
    "title": "exam1",
    "section": "",
    "text": "1 Introduction\n2 Review\nAdv Data Viz\n\nCodelibrary(dplyr)\nlibrary(tidyverse)\nlibrary(lubridate)\nlibrary(readr)\n\nweather_clean &lt;- weather_clean |&gt; \n  janitor::clean_names()\n\nweather_clean$date_in_year &lt;- as.Date(weather_clean$date_in_year - 1, origin = \"2021-01-01\")\n\ntemp &lt;- ggplot(weather_clean, aes(x = date_in_year)) +\n  geom_linerange(aes(\n    ymin = record_low,\n    ymax = record_high),\n    color = \"#ECEBE3\") +\n  geom_linerange(aes(\n    ymin = normal_low,\n    ymax = normal_high),\n    color = \"#C8B8BA\") +\n  geom_linerange(aes(\n    ymin = low,\n    ymax = high),\n    color = \"#A90248\") +\n  scale_x_date(\n    date_labels = \"%b\",        # Short month names (Jan, Feb, ...)\n    date_breaks = \"1 month\"    # Tick every month\n  ) +\n  theme_classic() +\n  theme(axis.title = element_blank(),\n    axis.text.y = element_text(size = 8),\n    axis.text.x = element_text(size = 9),\n    panel.grid = element_blank())\n\nprec &lt;- ggplot(weather_clean) +\n  geom_area(aes(x = date_in_year, y = culm_prec), fill = \"#ebeae2\", color = \"#32a3d8\") +\n  geom_point(\n    data = subset(weather_clean, record_precip == TRUE),\n    aes(y = culm_prec),\n    shape = 17,\n    size = 2,\n    color = \"#32a3d8\"\n  ) +\n  scale_x_date(date_labels = \"%b\", date_breaks = \"1 month\") +\n  theme_classic()\n\n\n\nCodelibrary(patchwork)\ntemp / prec + plot_layout(widths = c(2, 1), heights = c(3, 1))\n\n\n\n\n\n\n\n6 Adv Data Wrangling P1\nLogicals\n\nCodex &lt;- c(TRUE, FALSE, NA)\nx\n\n[1]  TRUE FALSE    NA\n\nCodeclass(x)\n\n[1] \"logical\"\n\n\nYou will often create logical vectors with comparison operators: &gt;, &lt;, &lt;=, &gt;=, ==, !=.\n\nCodex &lt;- c(1, 2, 9, 12)\nx &lt; 2\n\n[1]  TRUE FALSE FALSE FALSE\n\nCodex &lt;= 2\n\n[1]  TRUE  TRUE FALSE FALSE\n\nCodex &gt; 9\n\n[1] FALSE FALSE FALSE  TRUE\n\nCodex &gt;= 9\n\n[1] FALSE FALSE  TRUE  TRUE\n\nCodex == 12\n\n[1] FALSE FALSE FALSE  TRUE\n\nCodex != 12\n\n[1]  TRUE  TRUE  TRUE FALSE\n\n\nWhen you want to check for set containment, the %in% operator is the correct way to do this (as opposed to ==).\n\nCodex &lt;- c(1, 2, 9, 4)\nx == c(1, 2, 4)\n\n[1]  TRUE  TRUE FALSE FALSE\n\nCodex %in% c(1, 2, 4)\n\n[1]  TRUE  TRUE FALSE  TRUE\n\n\nThe Warning: longer object length is not a multiple of shorter object length is a manifestation of vector recycling.\nIn R, if two vectors are being combined or compared, the shorter one will be repeated to match the length of the longer one‚Äìeven if longer object length isn‚Äôt a multiple of the shorter object length. We can see the exact recycling that happens below:\n\nCodex &lt;- c(1, 2, 9, 4)\nx == c(1, 2, 4)\n\n[1]  TRUE  TRUE FALSE FALSE\n\nCodex == c(1, 2, 4, 1) # This line demonstrates the recycling that happens on the previous line\n\n[1]  TRUE  TRUE FALSE FALSE\n\n\nLogical vectors can also be created with functions. is.na() is one useful example:\n\nCodex &lt;- c(1, 4, 9, NA)\nx == NA\n\n[1] NA NA NA NA\n\nCodeis.na(x)\n\n[1] FALSE FALSE FALSE  TRUE\n\n\nWe can negate a logical object with !. We can combine logical objects with & (and) and | (or).\n\nCodex &lt;- c(1, 2, 4, 9)\nx &gt; 1 & x &lt; 5\n\n[1] FALSE  TRUE  TRUE FALSE\n\nCode!(x &gt; 1 & x &lt; 5)\n\n[1]  TRUE FALSE FALSE  TRUE\n\nCodex &lt; 2 | x &gt; 8\n\n[1]  TRUE FALSE FALSE  TRUE\n\n\nWe can summarize logical vectors with:\nany(): Are ANY of the values TRUE? all(): Are ALL of the values TRUE? sum(): How many of the values are TRUE? mean(): What fraction of the values are TRUE?\n\nCodex &lt;- c(1, 2, 4, 9)\nany(x == 1)\n\n[1] TRUE\n\nCodeall(x &lt; 10)\n\n[1] TRUE\n\nCodesum(x == 1)\n\n[1] 1\n\nCodemean(x == 1)\n\n[1] 0.25\n\n\nif_else() and case_when() are functions that allow you to return values depending on the value of a logical vector. You‚Äôll explore the documentation for these in the following exercises.\nNote: ifelse() (from base R) and if_else() (from tidyverse) are different functions. We prefer if_else() for many reasons (examples below).\nNoisy to make sure you catch issues/bugs Can explicitly handle missing values Keeps dates as dates\n\nCodex &lt;- c(-1, -2, 4, 9, NA)\n\nifelse(x &gt; 0, 'positive', 'negative')\n\n[1] \"negative\" \"negative\" \"positive\" \"positive\" NA        \n\nCodeif_else(x &gt; 0, 'positive', 'negative')\n\n[1] \"negative\" \"negative\" \"positive\" \"positive\" NA        \n\nCodeifelse(x &gt; 0, 1, 'negative') # Bad: doesn't complain with combo of data types\n\n[1] \"negative\" \"negative\" \"1\"        \"1\"        NA        \n\nCode# if_else(x &gt; 0, 1, 'negative') # Good:noisy to make sure you catch issues\n\nif_else(x &gt; 0, 'positive', 'negative', missing = 'missing') # Good: can explicitly handle NA\n\n[1] \"negative\" \"negative\" \"positive\" \"positive\" \"missing\" \n\nCodefun_dates &lt;- mdy('1-1-2025') + 0:365\n # ifelse(fun_dates &lt; today(), fun_dates + years(), fun_dates) # Bad: converts dates to integers\n # if_else(fun_dates &lt; today(), fun_dates + years(), fun_dates) # Good: keeps dates as dates\n\n\n\nCodedata(diamonds)\ndiamonds &lt;- diamonds |&gt; \n    slice_head(n = 1000)\n\n# Subset to diamonds that are less than 400 dollars or more than 10000 dollars.\ndiamonds |&gt; \n    filter(price &lt; 400 | price &gt; 10000)\n\n# A tibble: 30 √ó 10\n   carat cut       color clarity depth table price     x     y     z\n   &lt;dbl&gt; &lt;ord&gt;     &lt;ord&gt; &lt;ord&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n 1  0.23 Ideal     E     SI2      61.5    55   326  3.95  3.98  2.43\n 2  0.21 Premium   E     SI1      59.8    61   326  3.89  3.84  2.31\n 3  0.23 Good      E     VS1      56.9    65   327  4.05  4.07  2.31\n 4  0.29 Premium   I     VS2      62.4    58   334  4.2   4.23  2.63\n 5  0.31 Good      J     SI2      63.3    58   335  4.34  4.35  2.75\n 6  0.24 Very Good J     VVS2     62.8    57   336  3.94  3.96  2.48\n 7  0.24 Very Good I     VVS1     62.3    57   336  3.95  3.98  2.47\n 8  0.26 Very Good H     SI1      61.9    55   337  4.07  4.11  2.53\n 9  0.22 Fair      E     VS2      65.1    61   337  3.87  3.78  2.49\n10  0.23 Very Good H     VS1      59.4    61   338  4     4.05  2.39\n# ‚Ñπ 20 more rows\n\nCode# Subset to diamonds that are between 500 and 600 dollars (inclusive).\ndiamonds |&gt; \n    filter(price &gt;= 500, price &lt;= 600)\n\n# A tibble: 90 √ó 10\n   carat cut       color clarity depth table price     x     y     z\n   &lt;dbl&gt; &lt;ord&gt;     &lt;ord&gt; &lt;ord&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n 1  0.35 Ideal     I     VS1      60.9  57     552  4.54  4.59  2.78\n 2  0.3  Premium   D     SI1      62.6  59     552  4.23  4.27  2.66\n 3  0.3  Ideal     D     SI1      62.5  57     552  4.29  4.32  2.69\n 4  0.3  Ideal     D     SI1      62.1  56     552  4.3   4.33  2.68\n 5  0.42 Premium   I     SI2      61.5  59     552  4.78  4.84  2.96\n 6  0.28 Ideal     G     VVS2     61.4  56     553  4.19  4.22  2.58\n 7  0.32 Ideal     I     VVS1     62    55.3   553  4.39  4.42  2.73\n 8  0.31 Very Good G     SI1      63.3  57     553  4.33  4.3   2.73\n 9  0.31 Premium   G     SI1      61.8  58     553  4.35  4.32  2.68\n10  0.24 Premium   E     VVS1     60.7  58     553  4.01  4.03  2.44\n# ‚Ñπ 80 more rows\n\nCode# How many diamonds are of either Fair, Premium, or Ideal cut (a total count)? What fraction of diamonds are of Fair, Premium, or Ideal cut?\n# First, do this a wrong way with ==. Predict the warning message that you will receive.\n# Second, do this the correct way with an appropriate logical operator.\n\n# Right way with %in%\ndiamonds |&gt; \n    mutate(is_fpi = cut %in% c(\"Fair\", \"Premium\", \"Ideal\")) |&gt; \n    summarize(num_fpi = sum(is_fpi), frac_fpi = mean(is_fpi))\n\n# A tibble: 1 √ó 2\n  num_fpi frac_fpi\n    &lt;int&gt;    &lt;dbl&gt;\n1     685    0.685\n\nCode# Are there any diamonds of Fair cut that are more than $3000? Are all diamonds of Ideal cut more than $2000?\ndiamonds |&gt; \n    filter(cut == \"Fair\") |&gt; \n    summarize(any_high = any(price &gt; 3000))\n\n# A tibble: 1 √ó 1\n  any_high\n  &lt;lgl&gt;   \n1 FALSE   \n\nCodediamonds |&gt; \n    filter(cut == \"Ideal\") |&gt; \n    summarize(all_high = all(price &gt; 2000))\n\n# A tibble: 1 √ó 1\n  all_high\n  &lt;lgl&gt;   \n1 FALSE   \n\nCode# Create two new categorized versions of price by looking up the documentation for if_else() and case_when():\n# price_cat1: ‚Äúlow‚Äù if price is less than 500 and ‚Äúhigh‚Äù otherwise\n# price_cat2: ‚Äúlow‚Äù if price is less than 500, ‚Äúmedium‚Äù if price is between 500 and 1000 dollars inclusive, and ‚Äúhigh‚Äù otherwise.\ndiamonds |&gt; \n    mutate(\n        price_cat1 = if_else(price &lt; 500, \"low\", \"high\"),\n        price_cat2 = case_when(\n            price &lt; 500 ~ \"low\",\n            price &gt;= 500 & price &lt;= 1000 ~ \"medium\",\n            price &gt; 1000 ~ \"high\"\n        )\n    )\n\n# A tibble: 1,000 √ó 12\n   carat cut       color clarity depth table price     x     y     z price_cat1\n   &lt;dbl&gt; &lt;ord&gt;     &lt;ord&gt; &lt;ord&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;     \n 1  0.23 Ideal     E     SI2      61.5    55   326  3.95  3.98  2.43 low       \n 2  0.21 Premium   E     SI1      59.8    61   326  3.89  3.84  2.31 low       \n 3  0.23 Good      E     VS1      56.9    65   327  4.05  4.07  2.31 low       \n 4  0.29 Premium   I     VS2      62.4    58   334  4.2   4.23  2.63 low       \n 5  0.31 Good      J     SI2      63.3    58   335  4.34  4.35  2.75 low       \n 6  0.24 Very Good J     VVS2     62.8    57   336  3.94  3.96  2.48 low       \n 7  0.24 Very Good I     VVS1     62.3    57   336  3.95  3.98  2.47 low       \n 8  0.26 Very Good H     SI1      61.9    55   337  4.07  4.11  2.53 low       \n 9  0.22 Fair      E     VS2      65.1    61   337  3.87  3.78  2.49 low       \n10  0.23 Very Good H     VS1      59.4    61   338  4     4.05  2.39 low       \n# ‚Ñπ 990 more rows\n# ‚Ñπ 1 more variable: price_cat2 &lt;chr&gt;\n\n\nNumerical data can be of class integer or numeric (representing real numbers).\n\nCodex &lt;- 1:3\nx\n\n[1] 1 2 3\n\nCodeclass(x)\n\n[1] \"integer\"\n\nCodex &lt;- c(1+1e-9, 2, 3)\nx\n\n[1] 1 2 3\n\nCodeclass(x)\n\n[1] \"numeric\"\n\n\n7 Adv Data Wrangling P2\n\nCodelibrary(stringr)\nstring1 &lt;- \"This is a string\"\nstring2 &lt;- 'If I want to include a \"quote\" inside a string, I use single quotes'\nstring3 &lt;- c(string1, string2) # string / character vector (of greater than length 1)\n\nstr_view(string1, html = TRUE)\n\n\n\n\n\nCreates a tab) (Creates a newline)\nCreating Strings\n\nCodedf_dates &lt;- tibble(\n    year = c(2000, 2001, 2002),\n    month = c(\"Jan\", \"Feb\", \"Mar\"),\n    day = c(3, 4, 5)\n)\n\ndf_dates |&gt;\n    mutate(\n        date1 = str_c(month, \"-\", day, \"-\", year),\n        date2 = str_glue(\"{month}-{day}-{year}\")\n    )\n\n# A tibble: 3 √ó 5\n   year month   day date1      date2     \n  &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;glue&gt;    \n1  2000 Jan       3 Jan-3-2000 Jan-3-2000\n2  2001 Feb       4 Feb-4-2001 Feb-4-2001\n3  2002 Mar       5 Mar-5-2002 Mar-5-2002\n\n\nExtracting Information with String\n\nCodedf &lt;- tibble(\n    word_id = 1:3,\n    word = c(\"replace\", \"match\", \"pattern\")\n)\n\ndf |&gt;\n    mutate(\n        word_length = str_length(word),\n        middle_pos = ceiling(word_length/2),\n        middle_letter = str_sub(word, middle_pos, middle_pos)\n    )\n\n# A tibble: 3 √ó 5\n  word_id word    word_length middle_pos middle_letter\n    &lt;int&gt; &lt;chr&gt;         &lt;int&gt;      &lt;dbl&gt; &lt;chr&gt;        \n1       1 replace           7          4 l            \n2       2 match             5          3 t            \n3       3 pattern           7          4 t            \n\n\nFinding patterns in strings with regular expressions\n\nCode# This regex finds \"a\" then \"b\" at most once (can't have 2 or more b's in a row)\nstr_view(c(\"a\", \"ab\", \"abb\"), \"ab?\")\n\n[1] ‚îÇ &lt;a&gt;\n[2] ‚îÇ &lt;ab&gt;\n[3] ‚îÇ &lt;ab&gt;b\n\nCode# There has to be an \"a\" followed by at least one b\n# This is why the first string \"a\" isn't matched\nstr_view(c(\"a\", \"ab\", \"abb\"), \"ab+\")\n\n[2] ‚îÇ &lt;ab&gt;\n[3] ‚îÇ &lt;abb&gt;\n\nCode# There must be an \"a\" and then any number of b's (including zero)\nstr_view(c(\"a\", \"ab\", \"abb\"), \"ab*\")\n\n[1] ‚îÇ &lt;a&gt;\n[2] ‚îÇ &lt;ab&gt;\n[3] ‚îÇ &lt;abb&gt;\n\nCodestr_view(words, \"[aeiou][aeiou]m\")\n\n[154] ‚îÇ cl&lt;aim&gt;\n[714] ‚îÇ r&lt;oom&gt;\n[735] ‚îÇ s&lt;eem&gt;\n[844] ‚îÇ t&lt;eam&gt;\n\nCodestr_view(fruit, \"aa|ee|ii|oo|uu\")\n\n [9] ‚îÇ bl&lt;oo&gt;d orange\n[33] ‚îÇ g&lt;oo&gt;seberry\n[47] ‚îÇ lych&lt;ee&gt;\n[66] ‚îÇ purple mangost&lt;ee&gt;n\n\nCode# Words that start with y\nstr_view(words, \"^y\")\n\n[975] ‚îÇ &lt;y&gt;ear\n[976] ‚îÇ &lt;y&gt;es\n[977] ‚îÇ &lt;y&gt;esterday\n[978] ‚îÇ &lt;y&gt;et\n[979] ‚îÇ &lt;y&gt;ou\n[980] ‚îÇ &lt;y&gt;oung\n\nCode# Words that don't start with y\nstr_view(words, \"^[^y]\")\n\n [1] ‚îÇ &lt;a&gt;\n [2] ‚îÇ &lt;a&gt;ble\n [3] ‚îÇ &lt;a&gt;bout\n [4] ‚îÇ &lt;a&gt;bsolute\n [5] ‚îÇ &lt;a&gt;ccept\n [6] ‚îÇ &lt;a&gt;ccount\n [7] ‚îÇ &lt;a&gt;chieve\n [8] ‚îÇ &lt;a&gt;cross\n [9] ‚îÇ &lt;a&gt;ct\n[10] ‚îÇ &lt;a&gt;ctive\n[11] ‚îÇ &lt;a&gt;ctual\n[12] ‚îÇ &lt;a&gt;dd\n[13] ‚îÇ &lt;a&gt;ddress\n[14] ‚îÇ &lt;a&gt;dmit\n[15] ‚îÇ &lt;a&gt;dvertise\n[16] ‚îÇ &lt;a&gt;ffect\n[17] ‚îÇ &lt;a&gt;fford\n[18] ‚îÇ &lt;a&gt;fter\n[19] ‚îÇ &lt;a&gt;fternoon\n[20] ‚îÇ &lt;a&gt;gain\n... and 954 more",
    "crumbs": [
      "Exam 1",
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>exam1</span>"
    ]
  },
  {
    "objectID": "src/exam/nyt_viz.html",
    "href": "src/exam/nyt_viz.html",
    "title": "Claire‚Äôs Exam 1",
    "section": "",
    "text": "About The Deep Dive\nI decided to follow Nick Paul‚Äôs Blog on the internet to learn how he approaches the process to creating a compelling data story. This blog recreates NYT‚Äôs COVID Tracker visualization which I looked at daily during the peak COVID epidemic. I highly enjoyed being able to understand the new labeling and data wrangling mechanisms that were introduced through this blog. It will certainly help me with activities in class that ask me to recreate this advanced visualizations.\nCodelibrary(dplyr)\nlibrary(readr)\nlibrary(ggplot2)\nCode# Reading from github dataset\nurl &lt;- \"https://raw.githubusercontent.com/nytimes/covid-19-data/master/us-states.csv\"\n\n# readr::read_csv\ndf_states &lt;- readr::read_csv(url)\n\n# glimpse dplyr function\nglimpse(df_states)\n\nRows: 61,942\nColumns: 5\n$ date   &lt;date&gt; 2020-01-21, 2020-01-22, 2020-01-23, 2020-01-24, 2020-01-24, 20‚Ä¶\n$ state  &lt;chr&gt; \"Washington\", \"Washington\", \"Washington\", \"Illinois\", \"Washingt‚Ä¶\n$ fips   &lt;chr&gt; \"53\", \"53\", \"53\", \"17\", \"53\", \"06\", \"17\", \"53\", \"04\", \"06\", \"17‚Ä¶\n$ cases  &lt;dbl&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 1, ‚Ä¶\n$ deaths &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ‚Ä¶\nCodedf_ny_raw &lt;- df_states %&gt;% \n    filter(state == \"New York\") \n\nglimpse(df_ny_raw)\n\nRows: 1,118\nColumns: 5\n$ date   &lt;date&gt; 2020-03-01, 2020-03-02, 2020-03-03, 2020-03-04, 2020-03-05, 20‚Ä¶\n$ state  &lt;chr&gt; \"New York\", \"New York\", \"New York\", \"New York\", \"New York\", \"Ne‚Ä¶\n$ fips   &lt;chr&gt; \"36\", \"36\", \"36\", \"36\", \"36\", \"36\", \"36\", \"36\", \"36\", \"36\", \"36‚Ä¶\n$ cases  &lt;dbl&gt; 1, 1, 2, 11, 22, 44, 89, 106, 142, 173, 217, 326, 421, 610, 732‚Ä¶\n$ deaths &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 6, 10, 18, 32, 39, 68‚Ä¶\nCodedf_ny_raw %&gt;% \n    ggplot(aes(x = date, y = cases)) +\n    geom_line()\n\n\n\n\n\n\nCode# The cases column has the cumulative cases up to that date.\n# Lag function takes the difference between the current date and the previous date.\n# = works in the same way as &lt;- \ndf_ny = df_ny_raw %&gt;% \n    mutate(cases = cases - lag(cases,\n                               default = 0))\n\ndf_ny %&gt;% \n    ggplot(aes(x = date, y = cases)) +\n    geom_line()\nCode# For day-to-day variability, sum the case counts from the current day and the previous 6 days and  \n# divide by 7 for days of week\n\ndf_ny_smooth = df_ny %&gt;% \n    mutate(smooth = sum(cases, \n                        lag(cases, 1), lag(cases, 2), \n                        lag(cases, 3), lag(cases, 4),\n                        lag(cases, 5), lag(cases, 6))\n                    /7)\n\n# Or, create a function to do so\nrolling_average &lt;- function(x, period = 7){\n    \n    total = x\n    \n    for(i in 1:period-1){\n        total = total + lag(x,i)\n    }\n    \n    return(total/period)\n    \n}\n\ndf_ny_smooth = df_ny %&gt;% \n    mutate(smooth = rolling_average(cases))\n\ndf_ny_smooth\n\n# A tibble: 1,118 √ó 6\n   date       state    fips  cases deaths smooth\n   &lt;date&gt;     &lt;chr&gt;    &lt;chr&gt; &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;\n 1 2020-03-01 New York 36        1      0   NA  \n 2 2020-03-02 New York 36        0      0   NA  \n 3 2020-03-03 New York 36        1      0   NA  \n 4 2020-03-04 New York 36        9      0   NA  \n 5 2020-03-05 New York 36       11      0   NA  \n 6 2020-03-06 New York 36       22      0   NA  \n 7 2020-03-07 New York 36       45      0   19.1\n 8 2020-03-08 New York 36       17      0   17.4\n 9 2020-03-09 New York 36       36      0   25.3\n10 2020-03-10 New York 36       31      0   28.9\n# ‚Ñπ 1,108 more rows\nCode# Basic Chart\nplot_nyt &lt;- df_ny_smooth %&gt;% \n    filter(!is.na(smooth)) %&gt;% \n    ggplot(aes(x = date, y = smooth)) +\n    geom_line(color = \"red\") + \n    geom_area(fill = \"red\", alpha = .25)\n\nplot_nyt\nCode# themes to note: panel.grid and background\nplot_nyt &lt;- plot_nyt +\ntheme(\n          panel.background = element_blank(),    \n          axis.text.y = element_text(angle = 0, vjust = -.5, \n                                     margin = margin(r = -30)),\n          panel.grid.minor = element_blank(),\n          panel.grid.major.x = element_blank(),\n          panel.grid.major.y = element_line(colour = 'light grey', \n                                          linetype = 'dashed',size = .35),\n          axis.ticks.x = element_line(color = \"light grey\"),\n          axis.ticks.y = element_blank(),\n          axis.line.x = element_line(colour = \"light grey\", linetype = \"solid\",\n                                     size = .5))\nplot_nyt\nCode# Adjusting the scales\nbreaks &lt;- scales::extended_breaks()(df_ny_smooth$smooth)\nbreaks &lt;- breaks[2:length(breaks)]\n\nplot_nyt &lt;- plot_nyt +\n    scale_x_date(expand = c(0,0),\n                 date_labels = \"%b-%Y\") +\n    scale_y_continuous(expand = c(0,0),\n                       breaks = breaks,\n                       limits = c(0,max(df_ny_smooth$smooth))) +\n    labs(y = NULL,\n         x = NULL,\n         title = \"New Reported Cases: New York\")\nplot_nyt\nCode# Creating label for the 7 day average; median of smooth dataframe\nmax_date = df_ny$date %&gt;% median() + 60\nmin_date = df_ny$date %&gt;% median() - 60\n\nlabel_vals = df_ny_smooth %&gt;% \n    filter(date &gt; min_date, date &lt; max_date) %&gt;% \n    arrange(desc(smooth)) %&gt;% \n    top_n(1)\n\nlabel_vals \n\n# A tibble: 1 √ó 6\n  date       state    fips  cases deaths smooth\n  &lt;date&gt;     &lt;chr&gt;    &lt;chr&gt; &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;\n1 2021-09-19 New York 36     7724  54479  6547.\nCodeplot_nyt +\n    annotate(\"text\", x = label_vals$date, \n             y = label_vals$smooth * 1.4, \n             label = \"7-day\\naverage\",\n             size = 3.5,\n             fontface = \"plain\") +\n    annotate(\"segment\", x = label_vals$date, xend = label_vals$date,\n             y = label_vals$smooth, \n             yend = label_vals$smooth * 1.2,\n             size = .25)",
    "crumbs": [
      "Exam 1",
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Claire's Exam 1</span>"
    ]
  },
  {
    "objectID": "src/exam/nyt_viz.html#things-i-learned",
    "href": "src/exam/nyt_viz.html#things-i-learned",
    "title": "Claire‚Äôs Exam 1",
    "section": "Things I learned",
    "text": "Things I learned\nI learned about dplyr function lag that takes a column that generates numbers cumulatively into one that subtracts previous values from the current one creating a day by day value.\nI also learned about how to create a loop in R studio to clean data. axis.text.y = element_text(angle = 0, vjust = -.5, margin = margin(r = -30)) would‚Äôve been helpful to know when I was doing hw2. The axis. functions were new to me and showed me how I can change labeling in ggplot.\nextended_breaks() function from the scales package to automatically generate ‚Äúnice‚Äù breaks (tick marks) for the y-axis based on the smooth column from the df_ny_smooth data frame.\nbreaks[2:length(breaks)] removes the first break value, typically 0. This is done to avoid a tick at 0 on the y-axis if it‚Äôs redundant or visually unhelpful.",
    "crumbs": [
      "Exam 1",
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Claire's Exam 1</span>"
    ]
  },
  {
    "objectID": "src/exam/cp1.html",
    "href": "src/exam/cp1.html",
    "title": "cp1",
    "section": "",
    "text": "Adv Data Viz CP\n\nWhat geom do I use to create a barplot using the original raw data (not summarized)?\ngeom_bar\n\n\nWhat geom do I use to create a barplot using already summarized data (from count())?\ngeom_col\n\n\nWhich of these geom lines of code provides a proportional bar chart?\n\nggplot(aes(x, fill) + geom_bar(position = ‚Äòfill‚Äô)\n\n\n\nAdv Spatial Viz P1 CP\n\nWhat are the two components of a CRS/GCS?\nDatum + Ellipsoid Model\n\n\nWhy is it insufficient to identify a location by its latitude and longitude?\nLongitude and latitude are calculated based on chosen a coordinate reference system (datum + ellipsoid model) and so that value of longitude and latitude of a location might change if the CRS changes.\n\n\nWhy do we need to be mindful about CRSs when working with different spatial datasets?\n\n\n\nDifferent CRSs may use different units (e.g., meters, feet). Consistency in units is essential for accurate distance and area calculations.\nJoining datasets from multiple sources requires a common CRS.\nDifferent datasets may use different CRSs. If these CRSs are not accounted for, the spatial points/regions will not align correctly on a map.\n\n\n\n\n\nAdv Data Wrangling P1 CP\n\nsqrt(2)^2 == 2 is [1] FALSE\nThe computer first calculates sqrt(2) and saves some but not all decimal places of 1.414214‚Ä¶ so when you square that number, it is almost but not quite 2.\n\n\nTRUE & NA\n[1] NA\n\n\nTRUE | NA\n[1] TRUE\n\n\nsum(c(TRUE,TRUE,FALSE,TRUE))\n3\n\n\nif_else(condition,true,false)\nUseful when you are transforming values of a vector if a particular condition holds.\n\n\nparse_number()\nUseful when you have a variable that has non-numeric symbols such as $, %, or commas that you want to remove and convert to an integer or double numeric vector.\n\n\nRecycling in R refers to\nthe repeating of a short vector when arithmetic (and logical operations) is used on two vectors of different lengths.\n\n\nround(530.3,-2)\n(530.3 %/% 100) * 100\n\n\nfct_relevel()\nMoving a small number of levels to the beginning of the ordering or manually reordering levels.\n\n\nfct_recode()\nTransforming the values/levels of a factor variable to new labels\n\n\nfct_reorder()\nReordering the values/levels of a factor variable to by a different numeric/quantitative variable\n\n\nfct_infreq()\nReordering the values/levels of a factor variable to by the frequency of the levels\n\n\nWhat is ISO8601?\nInternational standard for writing date-time, largest unit of time to smallest unit, yyyy-mm-dd hh:mm.\n\n\nTo work with dates and times in R, we should:\nConvert character vectors such as ‚Äú2024-07-23 1:35pm‚Äù to a date-time class (data type).\n\n\n\n\n\nAdv Data Wrangling P2 CP\n\nThe correct way to recreate paste0(‚ÄúLetter of the Day:‚Äù,letters) with str_c() is\nstr_c(‚ÄúLetter of the Day:‚Äù,letters, sep = ‚Äô‚Äô)\n\n\n‚Äúa, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z‚Äù\nstr_c(letters, collapse = ‚Äò,‚Äô)\nstr_flatten(letters,‚Äò,‚Äô)\n\n\nTo separate a vector of strings (deliminted by commas) into columns of strings, use\nseparate_wider_delim()\n\n\nFor the following string,\n\nx1 &lt;- ‚ÄútextNi1o was particularly bad this year‚Äù\none of these functions will give you meaningful data and one will not. Why?\nread_csv(x1)$text\nread_csv(x1, locale = locale(encoding = ‚ÄúLatin1‚Äù))$text\nNon-English (non-ASCII) characters can be encoded in a wide variety of ways and read_csv() uses UTF-8 encoding by default.\n\n7. Which of these characters means that a pattern is optional (matches 0 or 1 time)?\n?\n\n8. Which of these characters means that a pattern is repeats (at least once)?\n+\n\n9. To replace all forward slahes with backslashes in ‚Äúa/b/c/d/e‚Äù, use the following code:\nstr_replace_all(‚Äúa/b/c/d/e‚Äù,‚Äò/‚Äô,‚Äú\\\\‚Äù)\n\n10. A primary key is\nis a variable or set of variables that uniquely identifies each observation\n\n11. A foreign key is\nis a variable (or set of variables) that corresponds to a primary key in another table\n\n12. A natural join is\na join that uses all variables that appear in both data frames as the join key\n\n13. Some examples of a non-equi join:\ncross join and inequality join",
    "crumbs": [
      "Exam 1",
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>cp1</span>"
    ]
  },
  {
    "objectID": "src/appx/appx-sample1.html",
    "href": "src/appx/appx-sample1.html",
    "title": "Appendix A ‚Äî Appendix Sample 1",
    "section": "",
    "text": "Add content here",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>¬† <span class='chapter-title'>Appendix Sample 1</span>"
    ]
  },
  {
    "objectID": "src/appx/appx-sample2.html",
    "href": "src/appx/appx-sample2.html",
    "title": "Appendix B ‚Äî Appendix Sample 2",
    "section": "",
    "text": "Add content here",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>¬† <span class='chapter-title'>Appendix Sample 2</span>"
    ]
  },
  {
    "objectID": "mm/mm.html",
    "href": "mm/mm.html",
    "title": "Appendix C ‚Äî Mind Maps",
    "section": "",
    "text": "Creativity",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>¬† <span class='chapter-title'>Mind Maps</span>"
    ]
  },
  {
    "objectID": "mm/mm.html#creativity",
    "href": "mm/mm.html#creativity",
    "title": "Appendix C ‚Äî Mind Maps",
    "section": "",
    "text": "0808-mind_map_example.jpg",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>¬† <span class='chapter-title'>Mind Maps</span>"
    ]
  },
  {
    "objectID": "mm/mm.html#review",
    "href": "mm/mm.html#review",
    "title": "Appendix C ‚Äî Mind Maps",
    "section": "Review",
    "text": "Review\n\n\n\nreview-mm.png",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>¬† <span class='chapter-title'>Mind Maps</span>"
    ]
  },
  {
    "objectID": "mm/mm.html#advanced-data-visualization",
    "href": "mm/mm.html#advanced-data-visualization",
    "title": "Appendix C ‚Äî Mind Maps",
    "section": "Advanced Data Visualization",
    "text": "Advanced Data Visualization\n\n\n\nadv-data-viz.jpg",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>¬† <span class='chapter-title'>Mind Maps</span>"
    ]
  },
  {
    "objectID": "mm/mm.html#missing-data",
    "href": "mm/mm.html#missing-data",
    "title": "Appendix C ‚Äî Mind Maps",
    "section": "Missing Data",
    "text": "Missing Data\n\n\n\nwrangling.jpg",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>¬† <span class='chapter-title'>Mind Maps</span>"
    ]
  }
]